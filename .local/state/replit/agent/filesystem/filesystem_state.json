{"file_contents":{"API_REFERENCE.md":{"content":"# API Reference\n\n## LavalinkManager\n\nThe main class for managing Lavalink nodes and players.\n\n### Constructor\n\n```typescript\nnew LavalinkManager(options: LavalinkManagerOptions)\n```\n\n#### LavalinkManagerOptions\n\n| Property | Type | Required | Description |\n|----------|------|----------|-------------|\n| nodes | NodeOptions[] | Yes | Array of Lavalink node configurations |\n| sendPayload | (guildId: string, payload: any) => void | Yes | Function to send Discord gateway payloads |\n| validationOptions | ValidationOptions | No | URL and track validation options |\n| autoResume | boolean | No | Enable automatic session resuming |\n| defaultSearchPlatform | SearchPlatform | No | Default platform for searches |\n| playerOptions | DefaultPlayerOptions | No | Default player configuration |\n\n### Methods\n\n#### `init(clientId: string): Promise<void>`\nInitialize the manager and connect to all nodes.\n\n#### `search(query: string, requester?: any, source?: SearchPlatform): Promise<SearchResult>`\nSearch for tracks.\n\n#### `createPlayer(options: PlayerOptions, queueStore?: QueueStore): Player`\nCreate a new player for a guild.\n\n#### `getPlayer(guildId: string): Player | undefined`\nGet an existing player.\n\n#### `destroyPlayer(guildId: string, reason?: DestroyReasons): Promise<void>`\nDestroy a player and clean up resources.\n\n#### `updateVoiceState(data: any): void`\nUpdate voice state from Discord.\n\n#### `updateVoiceServer(data: any): void`\nUpdate voice server from Discord.\n\n### Events\n\n```typescript\nmanager.on('ready', (node: Node) => {});\nmanager.on('nodeConnect', (node: Node) => {});\nmanager.on('nodeDisconnect', (node: Node, reason: string) => {});\nmanager.on('nodeError', (node: Node, error: Error) => {});\nmanager.on('trackStart', (player: Player, track: Track) => {});\nmanager.on('trackEnd', (player: Player, track: Track, reason: TrackEndReason) => {});\nmanager.on('trackError', (player: Player, track: Track, error: TrackException) => {});\nmanager.on('trackStuck', (player: Player, track: Track, thresholdMs: number) => {});\nmanager.on('autoPlayTrack', (player: Player, track: Track) => {});\nmanager.on('queueEnd', (player: Player) => {});\nmanager.on('playerCreate', (player: Player) => {});\nmanager.on('playerDestroy', (player: Player, reason: DestroyReasons) => {});\n```\n\n---\n\n## Player\n\nRepresents a music player for a guild.\n\n### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| guildId | string | Guild ID |\n| voiceChannelId | string | Voice channel ID |\n| textChannelId | string \\| undefined | Text channel ID |\n| node | Node | Connected Lavalink node |\n| queue | Queue | Player queue |\n| filters | FilterManager | Audio filter manager |\n| volume | number | Current volume (0-1000) |\n| paused | boolean | Whether player is paused |\n| playing | boolean | Whether player is playing |\n| connected | boolean | Whether player is connected |\n| position | number | Current track position in ms |\n| ping | number | Player ping in ms |\n| autoPlay | boolean | Whether autoplay is enabled |\n\n### Methods\n\n#### `connect(options?: ConnectOptions): Promise<void>`\nConnect to voice channel.\n\n#### `play(options?: PlayOptions): Promise<void>`\nStart playing current or next track.\n\n#### `stop(): Promise<void>`\nStop playback.\n\n#### `pause(pause?: boolean): Promise<void>`\nPause or unpause playback.\n\n#### `resume(): Promise<void>`\nResume playback.\n\n#### `seek(position: number): Promise<void>`\nSeek to position in ms.\n\n#### `setVolume(volume: number): Promise<void>`\nSet volume (0-1000).\n\n#### `skip(): Promise<Track | null>`\nSkip to next track.\n\n#### `destroy(reason?: DestroyReasons): Promise<void>`\nDestroy the player.\n\n#### `setAutoPlay(enabled: boolean): void`\nEnable or disable autoplay. When enabled, the player will automatically play related YouTube tracks when the queue ends.\n\n---\n\n## Queue\n\nManages the track queue for a player.\n\n### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| current | Track \\| null | Currently playing track |\n| tracks | Track[] | Upcoming tracks |\n| previous | Track[] | Previously played tracks |\n| size | number | Number of upcoming tracks |\n| totalSize | number | Total tracks including current |\n| isEmpty | boolean | Whether queue is empty |\n| duration | number | Total duration in ms |\n\n### Methods\n\n#### `add(track: Track | Track[]): Promise<void>`\nAdd track(s) to queue.\n\n#### `remove(index: number): Promise<Track | null>`\nRemove track at index.\n\n#### `clear(): Promise<void>`\nClear all tracks.\n\n#### `shuffle(): Promise<void>`\nShuffle the queue.\n\n#### `skipTo(index: number): Promise<Track | null>`\nSkip to track at index.\n\n#### `get(index: number): Track | null`\nGet track at index.\n\n---\n\n## FilterManager\n\nManages audio filters for a player.\n\n### Methods\n\n#### `setEqualizer(bands: EqualizerBand[]): Promise<void>`\nSet custom equalizer bands (0-14).\n\n#### `setBassBoost(level: number): Promise<void>`\nApply bass boost (0-1).\n\n#### `setNightcore(enable: boolean): Promise<void>`\nToggle nightcore effect.\n\n#### `setVaporwave(enable: boolean): Promise<void>`\nToggle vaporwave effect.\n\n#### `set8D(enable: boolean): Promise<void>`\nToggle 8D audio effect.\n\n#### `setKaraoke(enable: boolean): Promise<void>`\nToggle karaoke effect.\n\n#### `setPreset(preset: PresetName): Promise<void>`\nApply a filter preset.\n\nAvailable presets:\n- `bassBoost`\n- `nightcore`\n- `vaporwave`\n- `eightD`\n- `trebleBass`\n- `soft`\n- `pop`\n- `electronic`\n- `rock`\n- `classical`\n- `karaoke`\n\n#### `setTimescale(speed?, pitch?, rate?): Promise<void>`\nSet timescale filter.\n\n#### `setTremolo(frequency?, depth?): Promise<void>`\nSet tremolo effect.\n\n#### `setVibrato(frequency?, depth?): Promise<void>`\nSet vibrato effect.\n\n#### `setRotation(rotationHz?): Promise<void>`\nSet rotation effect.\n\n#### `setDistortion(options): Promise<void>`\nSet distortion filter.\n\n#### `setChannelMix(options): Promise<void>`\nSet channel mix filter.\n\n#### `setLowPass(smoothing?): Promise<void>`\nSet low-pass filter.\n\n#### `setAudioOutput(type: 'mono' | 'stereo' | 'left' | 'right'): Promise<void>`\nSet audio output channel configuration.\n\n#### `setEcho(delay?, decay?): Promise<void>`\nSet echo effect (requires lavalink-filter-plugin).\n- `delay`: Echo delay in seconds (default: 1)\n- `decay`: Echo decay factor 0-1 (default: 0.5)\n\n#### `setReverb(delays?, gains?): Promise<void>`\nSet reverb effect (requires lavalink-filter-plugin).\n- `delays`: Array of delay values (default: [0.037, 0.042, 0.048, 0.053])\n- `gains`: Array of gain values (default: [0.84, 0.83, 0.82, 0.81])\n\n#### `setHighPass(cutoffFrequency?, boostFactor?): Promise<void>`\nSet high-pass filter (requires lavadspx-plugin).\n- `cutoffFrequency`: Frequency cutoff in Hz (default: 1475)\n- `boostFactor`: Volume boost factor (default: 1.0)\n\n#### `setPluginLowPass(cutoffFrequency?, boostFactor?): Promise<void>`\nSet plugin low-pass filter (requires lavadspx-plugin).\n- `cutoffFrequency`: Frequency cutoff in Hz (default: 284)\n- `boostFactor`: Volume boost factor (default: 1.0)\n\n#### `setNormalization(maxAmplitude?, adaptive?): Promise<void>`\nSet audio normalization (requires lavadspx-plugin).\n- `maxAmplitude`: Maximum amplitude 0-1 (default: 0.75)\n- `adaptive`: Enable adaptive normalization (default: true)\n\n#### `clearFilters(): Promise<void>`\nRemove all filters.\n\n#### `setVolume(volume: number): Promise<void>`\nSet volume as filter (0-5).\n\n---\n\n## Track\n\nRepresents a music track.\n\n### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| encoded | string | Lavalink track encoding |\n| title | string | Track title |\n| author | string | Track author |\n| duration | number | Track duration in ms |\n| uri | string \\| undefined | Track URL |\n| thumbnail | string \\| undefined | Artwork URL |\n| identifier | string | Track identifier |\n| isStream | boolean | Whether track is a stream |\n| isSeekable | boolean | Whether track is seekable |\n| sourceName | string | Source platform name |\n| requester | any | User who requested track |\n\n### Methods\n\n#### `toJSON(): LavalinkTrack`\nConvert to JSON.\n\n#### `clone(): Track`\nCreate a copy of the track.\n\n---\n\n## MusicCardGenerator\n\nUtility for generating visual music cards using the musicard package.\n\n**Note**: The `musicard` package is included with aliana-client, so no additional installation is required!\n\n### Static Methods\n\n#### `generateCard(track: Track, options?: MusicCardOptions, theme?: MusicCardTheme): Promise<Buffer>`\nGenerate a music card for a track.\n\n**Parameters:**\n- `track`: The track to generate a card for\n- `options`: Optional customization options (see MusicCardOptions below)\n- `theme`: Theme to use ('classic', 'classicPro', or 'dynamic')\n\n**Returns:** PNG image buffer\n\n#### `generateCardWithProgress(track: Track, currentPosition: number, options?: MusicCardOptions, theme?: MusicCardTheme): Promise<Buffer>`\nGenerate a music card with current playback progress.\n\n**Parameters:**\n- `track`: The track to generate a card for\n- `currentPosition`: Current playback position in ms\n- `options`: Optional customization options\n- `theme`: Theme to use\n\n**Returns:** PNG image buffer\n\n#### `isAvailable(): boolean`\nCheck if musicard package is installed and available.\n\n### MusicCardOptions\n\n| Property | Type | Description |\n|----------|------|-------------|\n| thumbnailImage | string | Album artwork URL |\n| backgroundColor | string | Card background color (hex) |\n| progress | number | Progress percentage (0-100) |\n| progressColor | string | Progress bar color (hex) |\n| progressBarColor | string | Progress bar background color (hex) |\n| name | string | Track title |\n| nameColor | string | Title text color (hex) |\n| author | string | Artist name |\n| authorColor | string | Artist text color (hex) |\n| startTime | string | Current time (e.g., \"2:30\") |\n| endTime | string | Total duration (e.g., \"4:00\") |\n| timeColor | string | Time text color (hex) |\n\n### Example Usage\n\n```typescript\nimport { MusicCardGenerator, Player } from 'aliana-client';\nimport fs from 'fs';\n\n// Check if musicard is available\nif (MusicCardGenerator.isAvailable()) {\n  const player: Player = /* your player */;\n  const track = player.queue.current;\n  \n  if (track) {\n    // Generate a simple card\n    const card = await MusicCardGenerator.generateCard(track);\n    fs.writeFileSync('now-playing.png', card);\n    \n    // Generate card with progress\n    const cardWithProgress = await MusicCardGenerator.generateCardWithProgress(\n      track,\n      player.position,\n      {\n        backgroundColor: '#1a1a1a',\n        progressColor: '#00ff00',\n      },\n      'classicPro'\n    );\n    fs.writeFileSync('now-playing-progress.png', cardWithProgress);\n  }\n}\n```\n\n---\n\n## Node\n\nRepresents a Lavalink node connection.\n\n### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| identifier | string | Node identifier |\n| options | ProcessedNodeOptions | Node configuration |\n| stats | NodeStats \\| null | Node statistics |\n| info | LavalinkNodeInfo \\| null | Node information |\n| isConnected | boolean | Connection status |\n| address | string | Node address |\n| wsAddress | string | WebSocket URL |\n| restAddress | string | REST API URL |\n\n### Methods\n\n#### `connect(clientId: string, resumeKey?: string): Promise<void>`\nConnect to node.\n\n#### `disconnect(): Promise<void>`\nDisconnect from node.\n\n#### `send(payload: any): void`\nSend WebSocket payload.\n\n#### `request<T>(endpoint: string, options?: any): Promise<T>`\nMake REST API request.\n\n#### `fetchInfo(): Promise<LavalinkNodeInfo>`\nFetch node information.\n\n---\n\n## Types\n\n### SearchPlatform\n```typescript\ntype SearchPlatform = \n  | 'youtube' \n  | 'youtubemusic' \n  | 'soundcloud' \n  | 'spotify' \n  | 'deezer' \n  | 'applemusic' \n  | 'yandex';\n```\n\n### DestroyReasons\n```typescript\nenum DestroyReasons {\n  NodeDestroy,\n  NodeReconnect,\n  LavalinkNoVoice,\n  NodeDeleted,\n  PlayerReconnect,\n  Disconnected,\n  PlayerMovedChannels,\n  ChannelDeleted,\n  QueueEmpty,\n  TrackStuck,\n  TrackError,\n  Cleanup,\n}\n```\n\n### TrackEndReason\n```typescript\ntype TrackEndReason = \n  | 'finished' \n  | 'loadFailed' \n  | 'stopped' \n  | 'replaced' \n  | 'cleanup';\n```\n","size_bytes":12117},"CHANGELOG.md":{"content":"# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [1.0.0] - 2025-11-17\n\n### Added\n- Initial release of Aliana-client\n- Full Lavalink v4 support with native WebSocket implementation\n- Advanced Player class with audio normalizer\n- Flexible Queue system with pluggable stores\n- Memory and Redis store adapters\n- Comprehensive audio filter system with presets:\n  - Bass Boost\n  - Nightcore\n  - Vaporwave\n  - 8D Audio\n  - Karaoke\n  - Treble Bass\n  - Electronic\n  - Rock\n  - Classical\n  - Pop\n  - Soft\n- Client-side and server-side validation\n- Unresolved track support with lazy loading\n- Detailed player destroy reasons\n- Auto-handling for voice events and errors\n- TypeScript type definitions\n- Complete API documentation\n- Usage examples\n\n### Features\n- ðŸ’¯ Native Lavalink v4 support\n- âœ¨ Enhanced audio quality with built-in normalizer\n- ðŸŽšï¸ 10+ filter presets ready to use\n- ðŸ”„ Flexible queue stores (in-memory, Redis)\n- ðŸŽ¶ Smart unresolved track handling\n- ðŸ›¡ï¸ Client and server-side validation\n- ðŸ¤– Automatic error handling and recovery\n- ðŸ“– Comprehensive documentation\n\n## [Unreleased]\n\n### Planned\n- Advanced audio effects (reverb, pitch shift, tremolo, vibrato)\n- Cross-server queue synchronization\n- Visual audio analyzer\n- Lyrics fetching and synchronization\n- Automatic playlist management\n- Smart shuffle algorithms\n","size_bytes":1550},"src/filters/presets.ts":{"content":"import type { FilterData } from '../types';\n\nexport const FILTER_PRESETS = {\n  bassBoost: (level?: number): FilterData => {\n    const gain = Math.max(0, Math.min(1, level ?? 0.5));\n    return {\n      equalizer: [\n        { band: 0, gain: gain * 0.6 },\n        { band: 1, gain: gain * 0.67 },\n        { band: 2, gain: gain * 0.33 },\n        { band: 3, gain: 0 },\n        { band: 4, gain: -0.5 * gain },\n      ],\n    };\n  },\n\n  nightcore: (): FilterData => ({\n    timescale: {\n      speed: 1.165,\n      pitch: 1.125,\n      rate: 1.0,\n    },\n    tremolo: {\n      frequency: 4.0,\n      depth: 0.75,\n    },\n  }),\n\n  vaporwave: (): FilterData => ({\n    timescale: {\n      speed: 0.8,\n      pitch: 0.75,\n      rate: 1.0,\n    },\n    equalizer: [\n      { band: 0, gain: 0.3 },\n      { band: 1, gain: 0.3 },\n    ],\n    tremolo: {\n      frequency: 14.0,\n      depth: 0.5,\n    },\n  }),\n\n  eightD: (): FilterData => ({\n    rotation: {\n      rotationHz: 0.2,\n    },\n  }),\n\n  trebleBass: (): FilterData => ({\n    equalizer: [\n      { band: 0, gain: 0.2 },\n      { band: 1, gain: 0.15 },\n      { band: 2, gain: 0 },\n      { band: 3, gain: 0 },\n      { band: 4, gain: 0.15 },\n      { band: 5, gain: 0.2 },\n    ],\n  }),\n\n  soft: (): FilterData => ({\n    lowPass: {\n      smoothing: 20.0,\n    },\n  }),\n\n  pop: (): FilterData => ({\n    equalizer: [\n      { band: 0, gain: -0.02 },\n      { band: 1, gain: -0.01 },\n      { band: 2, gain: 0.08 },\n      { band: 3, gain: 0.1 },\n      { band: 4, gain: 0.15 },\n      { band: 5, gain: 0.1 },\n      { band: 6, gain: 0.03 },\n    ],\n  }),\n\n  electronic: (): FilterData => ({\n    equalizer: [\n      { band: 0, gain: 0.375 },\n      { band: 1, gain: 0.35 },\n      { band: 2, gain: 0.125 },\n      { band: 3, gain: 0 },\n      { band: 4, gain: -0.125 },\n      { band: 5, gain: 0.125 },\n      { band: 6, gain: 0.25 },\n      { band: 7, gain: 0.125 },\n    ],\n  }),\n\n  rock: (): FilterData => ({\n    equalizer: [\n      { band: 0, gain: 0.3 },\n      { band: 1, gain: 0.25 },\n      { band: 2, gain: 0.2 },\n      { band: 3, gain: 0.1 },\n      { band: 4, gain: 0.05 },\n      { band: 5, gain: -0.05 },\n      { band: 6, gain: -0.15 },\n    ],\n  }),\n\n  classical: (): FilterData => ({\n    equalizer: [\n      { band: 0, gain: 0.375 },\n      { band: 1, gain: 0.35 },\n      { band: 2, gain: 0.125 },\n      { band: 3, gain: 0 },\n      { band: 4, gain: 0 },\n      { band: 5, gain: 0.125 },\n      { band: 6, gain: 0.15 },\n      { band: 7, gain: 0.05 },\n    ],\n  }),\n\n  karaoke: (): FilterData => ({\n    karaoke: {\n      level: 1.0,\n      monoLevel: 1.0,\n      filterBand: 220.0,\n      filterWidth: 100.0,\n    },\n  }),\n};\n\nexport type PresetName = keyof typeof FILTER_PRESETS;\n","size_bytes":2672},"src/structures/Queue.ts":{"content":"import type { QueueStore, QueueData } from '../types';\nimport { Track } from './Track';\nimport { EventEmitter } from 'events';\n\nexport class Queue extends EventEmitter {\n  private guildId: string;\n  private store: QueueStore;\n  public current: Track | null = null;\n  public tracks: Track[] = [];\n  public previous: Track[] = [];\n  private initPromise: Promise<void> | null = null;\n  private initialized: boolean = false;\n  private modified: boolean = false;\n  private player: any;\n  \n  constructor(guildId: string, store: QueueStore) {\n    super();\n    this.guildId = guildId;\n    this.store = store;\n  }\n  \n  setPlayer(player: any): void {\n    this.player = player;\n  }\n  \n  async initialize(): Promise<void> {\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n    \n    if (this.initialized) {\n      return;\n    }\n    \n    this.initPromise = this.performLoad();\n    return this.initPromise;\n  }\n  \n  private async performLoad(): Promise<void> {\n    try {\n      if (this.modified) {\n        return;\n      }\n      \n      await this.load();\n      this.initialized = true;\n    } catch (error) {\n      console.error(`Failed to load queue for guild ${this.guildId}:`, error);\n    }\n  }\n  \n  private markModified(): void {\n    this.modified = true;\n  }\n  \n  private async ensureInitialized(): Promise<void> {\n    if (!this.initialized && !this.initPromise) {\n      await this.initialize();\n    } else if (this.initPromise) {\n      await this.initPromise;\n    }\n  }\n\n  get size(): number {\n    return this.tracks.length;\n  }\n\n  get totalSize(): number {\n    return this.tracks.length + (this.current ? 1 : 0);\n  }\n\n  get isEmpty(): boolean {\n    return this.tracks.length === 0 && !this.current;\n  }\n\n  get duration(): number {\n    return this.tracks.reduce((acc, track) => acc + track.duration, 0) + \n           (this.current?.duration || 0);\n  }\n\n  async add(track: Track | Track[], isAutoPlay: boolean = false): Promise<void> {\n    await this.ensureInitialized();\n    this.markModified();\n    const tracksToAdd = Array.isArray(track) ? track : [track];\n    this.tracks.push(...tracksToAdd);\n    \n    if (!isAutoPlay && this.player) {\n      if (typeof this.player.setAutoPlaySession === 'function') {\n        this.player.setAutoPlaySession(false);\n      }\n      if (typeof this.player.setAutoPlay === 'function') {\n        this.player.setAutoPlay(false);\n      }\n    }\n    \n    await this.save();\n    this.emit('add', tracksToAdd);\n  }\n\n  async remove(index: number): Promise<Track | null> {\n    await this.ensureInitialized();\n    if (index < 0 || index >= this.tracks.length) return null;\n    \n    this.markModified();\n    const removed = this.tracks.splice(index, 1)[0];\n    await this.save();\n    this.emit('remove', removed, index);\n    return removed;\n  }\n\n  async clear(): Promise<void> {\n    await this.ensureInitialized();\n    this.markModified();\n    const oldTracks = [...this.tracks];\n    this.tracks = [];\n    await this.save();\n    this.emit('clear', oldTracks);\n  }\n\n  async shuffle(): Promise<void> {\n    await this.ensureInitialized();\n    this.markModified();\n    for (let i = this.tracks.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [this.tracks[i], this.tracks[j]] = [this.tracks[j], this.tracks[i]];\n    }\n    await this.save();\n    this.emit('shuffle');\n  }\n\n  async setCurrent(track: Track | null): Promise<void> {\n    await this.ensureInitialized();\n    this.markModified();\n    if (this.current) {\n      this.previous.push(this.current);\n      if (this.previous.length > 100) {\n        this.previous.shift();\n      }\n    }\n    this.current = track;\n    await this.save();\n  }\n\n  async next(): Promise<Track | null> {\n    await this.ensureInitialized();\n    this.markModified();\n    const track = this.tracks.shift();\n    if (track) {\n      await this.setCurrent(track);\n      return track;\n    }\n    return null;\n  }\n\n  async skipTo(index: number): Promise<Track | null> {\n    await this.ensureInitialized();\n    if (index < 0 || index >= this.tracks.length) return null;\n    \n    this.markModified();\n    const track = this.tracks[index];\n    this.tracks.splice(0, index + 1);\n    await this.setCurrent(track);\n    return track;\n  }\n\n  get(index: number): Track | null {\n    return this.tracks[index] || null;\n  }\n\n  async save(): Promise<void> {\n    const data: QueueData = {\n      current: this.current?.toJSON() || null,\n      tracks: this.tracks.map(t => t.toJSON()),\n      previous: this.previous.map(t => t.toJSON()),\n    };\n    await this.store.set(this.guildId, data);\n  }\n\n  async load(): Promise<void> {\n    const data = await this.store.get(this.guildId);\n    if (data) {\n      this.current = data.current ? new Track(data.current) : null;\n      this.tracks = data.tracks.map(t => new Track(t));\n      this.previous = data.previous.map(t => new Track(t));\n    }\n  }\n}\n","size_bytes":4855},"src/stores/MemoryStore.ts":{"content":"import type { QueueStore, QueueData } from '../types';\n\nexport class MemoryStore implements QueueStore {\n  private data: Map<string, QueueData> = new Map();\n\n  async get(guildId: string): Promise<QueueData | null> {\n    return this.data.get(guildId) || null;\n  }\n\n  async set(guildId: string, data: QueueData): Promise<void> {\n    this.data.set(guildId, data);\n  }\n\n  async delete(guildId: string): Promise<void> {\n    this.data.delete(guildId);\n  }\n\n  async has(guildId: string): Promise<boolean> {\n    return this.data.has(guildId);\n  }\n\n  async clear(): Promise<void> {\n    this.data.clear();\n  }\n\n  get size(): number {\n    return this.data.size;\n  }\n}\n","size_bytes":657},"EXAMPLES.md":{"content":"# Aliana-client Examples\n\n## Basic Music Bot\n\n```typescript\nimport { Client, GatewayIntentBits } from 'discord.js';\nimport { LavalinkManager } from 'aliana-client';\n\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildVoiceStates,\n    GatewayIntentBits.GuildMessages,\n  ],\n});\n\nconst manager = new LavalinkManager({\n  nodes: [\n    {\n      host: 'localhost',\n      port: 2333,\n      password: 'youshallnotpass',\n    },\n  ],\n  sendPayload: (guildId, payload) => {\n    const guild = client.guilds.cache.get(guildId);\n    if (guild) guild.shard.send(payload);\n  },\n});\n\nmanager.on('trackStart', (player, track) => {\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel?.isTextBased()) {\n    channel.send(`Now playing: **${track.title}** by ${track.author}`);\n  }\n});\n\nclient.on('ready', async () => {\n  console.log(`Logged in as ${client.user!.tag}`);\n  await manager.init(client.user!.id);\n});\n\nclient.on('voiceStateUpdate', (oldState, newState) => {\n  manager.updateVoiceState(newState);\n});\n\nclient.ws.on('VOICE_SERVER_UPDATE' as any, (data: any) => {\n  manager.updateVoiceServer(data);\n});\n\nclient.login('YOUR_BOT_TOKEN');\n```\n\n## Play Command\n\n```typescript\nimport { SlashCommandBuilder } from 'discord.js';\n\nconst playCommand = {\n  data: new SlashCommandBuilder()\n    .setName('play')\n    .setDescription('Play a song')\n    .addStringOption(option =>\n      option.setName('query')\n        .setDescription('Song name or URL')\n        .setRequired(true)\n    ),\n  async execute(interaction) {\n    const query = interaction.options.getString('query', true);\n    const member = interaction.member;\n    \n    if (!member.voice.channel) {\n      return interaction.reply('You need to be in a voice channel!');\n    }\n\n    let player = manager.getPlayer(interaction.guildId);\n    \n    if (!player) {\n      player = manager.createPlayer({\n        guildId: interaction.guildId,\n        voiceChannelId: member.voice.channelId,\n        textChannelId: interaction.channelId,\n      });\n      await player.connect();\n    }\n\n    const result = await manager.search(query, interaction.user.id);\n\n    if (!result.tracks.length) {\n      return interaction.reply('No tracks found!');\n    }\n\n    const track = result.tracks[0];\n    await player.queue.add(track);\n\n    if (!player.playing) {\n      await player.play();\n      return interaction.reply(`Now playing: **${track.title}**`);\n    } else {\n      return interaction.reply(`Added to queue: **${track.title}**`);\n    }\n  },\n};\n```\n\n## Queue Management\n\n```typescript\nconst queueCommand = {\n  data: new SlashCommandBuilder()\n    .setName('queue')\n    .setDescription('Show the current queue'),\n  async execute(interaction) {\n    const player = manager.getPlayer(interaction.guildId);\n    \n    if (!player || player.queue.isEmpty) {\n      return interaction.reply('The queue is empty!');\n    }\n\n    const current = player.queue.current;\n    const upcoming = player.queue.tracks.slice(0, 10);\n\n    let description = `**Now Playing:**\\n${current!.title} by ${current!.author}\\n\\n`;\n    \n    if (upcoming.length) {\n      description += `**Up Next:**\\n`;\n      upcoming.forEach((track, i) => {\n        description += `${i + 1}. ${track.title} by ${track.author}\\n`;\n      });\n    }\n\n    return interaction.reply({ embeds: [{ description }] });\n  },\n};\n```\n\n## Skip Command\n\n```typescript\nconst skipCommand = {\n  data: new SlashCommandBuilder()\n    .setName('skip')\n    .setDescription('Skip the current song'),\n  async execute(interaction) {\n    const player = manager.getPlayer(interaction.guildId);\n    \n    if (!player) {\n      return interaction.reply('No player found!');\n    }\n\n    const skipped = player.queue.current;\n    await player.skip();\n\n    return interaction.reply(`Skipped: **${skipped!.title}**`);\n  },\n};\n```\n\n## Autoplay Command\n\n```typescript\nconst autoplayCommand = {\n  data: new SlashCommandBuilder()\n    .setName('autoplay')\n    .setDescription('Toggle autoplay (plays related YouTube tracks when queue ends)'),\n  async execute(interaction) {\n    const player = manager.getPlayer(interaction.guildId);\n    \n    if (!player) {\n      return interaction.reply('No player found! Use /play first.');\n    }\n\n    player.setAutoPlay(!player.autoPlay);\n\n    return interaction.reply(\n      player.autoPlay\n        ? 'âœ… Autoplay **enabled**. I will play related YouTube tracks when the queue ends!'\n        : 'âŒ Autoplay **disabled**. Music will stop when the queue ends.'\n    );\n  },\n};\n```\n\nWhen autoplay is enabled, the bot will automatically search for and play related tracks when the queue ends, similar to Spotify's autoplay feature.\n\n**How it works:**\n- When the queue becomes empty and autoplay is enabled, the system searches for tracks related to the last played track\n- If related tracks are found, one is randomly selected and added to the queue, then playback continues\n- This process repeats each time the queue ends, creating a continuous listening experience\n- If no related tracks are found, the `queueEnd` event is emitted and playback stops\n- Disabling autoplay will stop this automatic behavior and emit `queueEnd` when the queue finishes\n\nYou can listen to the `autoPlayTrack` event to notify users when an autoplay track starts:\n\n```typescript\nmanager.on('autoPlayTrack', (player, track) => {\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel?.isTextBased()) {\n    channel.send(`ðŸŽµ Autoplay: Now playing **${track.title}** by ${track.author}`);\n  }\n});\n```\n\n## Audio Filters\n\n```typescript\nconst bassBoostCommand = {\n  data: new SlashCommandBuilder()\n    .setName('bassboost')\n    .setDescription('Apply bass boost filter')\n    .addNumberOption(option =>\n      option.setName('level')\n        .setDescription('Bass boost level (0-1)')\n        .setMinValue(0)\n        .setMaxValue(1)\n    ),\n  async execute(interaction) {\n    const player = manager.getPlayer(interaction.guildId);\n    const level = interaction.options.getNumber('level') ?? 0.5;\n    \n    await player.filters.setBassBoost(level);\n    return interaction.reply(`Applied bass boost at ${level * 100}%`);\n  },\n};\n\nconst nightcoreCommand = {\n  data: new SlashCommandBuilder()\n    .setName('nightcore')\n    .setDescription('Toggle nightcore effect'),\n  async execute(interaction) {\n    const player = manager.getPlayer(interaction.guildId);\n    await player.filters.setNightcore(true);\n    return interaction.reply('Nightcore effect enabled!');\n  },\n};\n\nconst filterPresetCommand = {\n  data: new SlashCommandBuilder()\n    .setName('preset')\n    .setDescription('Apply a filter preset')\n    .addStringOption(option =>\n      option.setName('preset')\n        .setDescription('Choose a preset')\n        .setRequired(true)\n        .addChoices(\n          { name: 'Bass Boost', value: 'bassBoost' },\n          { name: 'Nightcore', value: 'nightcore' },\n          { name: 'Vaporwave', value: 'vaporwave' },\n          { name: '8D Audio', value: 'eightD' },\n          { name: 'Karaoke', value: 'karaoke' }\n        )\n    ),\n  async execute(interaction) {\n    const player = manager.getPlayer(interaction.guildId);\n    const preset = interaction.options.getString('preset', true);\n    \n    await player.filters.setPreset(preset as any);\n    return interaction.reply(`Applied ${preset} preset!`);\n  },\n};\n```\n\n## Custom Queue Store (Redis)\n\n```typescript\nimport { createClient } from 'redis';\nimport { RedisStoreAdapter } from 'aliana-client';\n\nconst redisClient = createClient();\nawait redisClient.connect();\n\nconst redisStore = new RedisStoreAdapter({\n  get: async (key) => await redisClient.get(key),\n  set: async (key, value) => await redisClient.set(key, value),\n  del: async (key) => await redisClient.del(key),\n  exists: async (key) => await redisClient.exists(key) === 1,\n});\n\nconst player = manager.createPlayer({\n  guildId: 'GUILD_ID',\n  voiceChannelId: 'VOICE_CHANNEL_ID',\n  queueStore: redisStore,\n});\n```\n\n## Advanced Player Controls\n\n```typescript\nconst player = manager.getPlayer(guildId);\n\nawait player.setVolume(150);\n\nawait player.seek(60000);\n\nawait player.pause();\nawait player.resume();\n\nawait player.queue.shuffle();\n\nawait player.queue.skipTo(5);\n\nawait player.queue.clear();\n\nawait player.destroy();\n```\n\n## Error Handling\n\n```typescript\nmanager.on('trackError', (player, track, error) => {\n  console.error(`Error playing ${track.title}:`, error.message);\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel?.isTextBased()) {\n    channel.send(`Error playing track: ${error.message}`);\n  }\n});\n\nmanager.on('trackStuck', (player, track, threshold) => {\n  console.warn(`Track ${track.title} is stuck for ${threshold}ms`);\n});\n\nmanager.on('nodeDisconnect', (node, reason) => {\n  console.error(`Node ${node.identifier} disconnected: ${reason}`);\n});\n```\n\n## Auto-leave on Empty Queue\n\n```typescript\nmanager.on('queueEnd', async (player) => {\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel?.isTextBased()) {\n    channel.send('Queue ended. Leaving voice channel...');\n  }\n  \n  await player.destroy();\n});\n```\n","size_bytes":9115},"README.md":{"content":"# ðŸŽµ Aliana-client\n\n> A premium TypeScript Lavalink v4 client with enhanced audio quality, advanced features, and comprehensive documentation.\n\n[![npm version](https://img.shields.io/npm/v/aliana-client.svg?style=for-the-badge&logo=npm&logoColor=red)](https://www.npmjs.com/package/aliana-client)\n[![npm downloads](https://img.shields.io/npm/dt/aliana-client.svg?style=for-the-badge&logo=npm&logoColor=red)](https://www.npmjs.com/package/aliana-client)\n[![TypeScript](https://img.shields.io/badge/typescript-%23007ACC.svg?style=for-the-badge&logo=typescript&logoColor=white)](https://www.typescriptlang.org/)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg?style=for-the-badge)](https://opensource.org/licenses/MIT)\n\n---\n\n## ðŸš€ Features\n\n- ðŸ’¯ **Lavalink v4 Native**: Full support for Lavalink v4, including its powerful plugin ecosystem\n- âœ… **Detailed Player-Destroy Reasons**: Understand precisely why a player was destroyed (e.g., channel deleted, bot disconnected)\n- âœ¨ **Flexible Queue Stores**: Use the default in-memory store or bring your own (Redis, databases, etc.) to sync queues across multiple processes\n- ðŸŽ¶ **Unresolved Tracks**: Supports unresolved track objects, fetching full data only when a track is about to play, saving API requests and resources\n- ðŸŽšï¸ **Built-in Filters & EQ**: Easy-to-use management for audio filters and equalizers with presets\n- âš™ï¸ **Advanced Player Options**: Fine-tune player behavior for disconnects, empty queues, volume handling, and more\n- ðŸ›¡ï¸ **Lavalink-Side Validation**: Ensures you only use filters, plugins, and sources that your Lavalink node actually supports\n- ðŸ”’ **Client-Side Validation**: Whitelist and blacklist URLs or domains to prevent unwanted requests and protect your bot\n- ðŸ§‘â€ðŸ’» **Developer-Friendly**: A memory-efficient design with a clean, intuitive API\n- ðŸ¤– **Automated Handling**: Automatically handles track skipping on errors, voice channel deletions, server-wide mutes, and much more\n- ðŸŽµ **Enhanced Audio Quality**: Built-in audio normalizer for consistent volume levels\n- ðŸŒˆ **Rich Filter Presets**: Bass boost, nightcore, vaporwave, 8D audio, echo, reverb, and more\n- ðŸŽ¨ **Built-in Music Cards**: Generate beautiful visual music cards with the included musicard integration\n- ðŸ”„ **Smart Autoplay**: Intelligent track recommendations that play different, similar songs like Spotify\n\n---\n\n## ðŸ“¦ Installation\n\n**Latest Stable Version: `v1.0.0`**\n\n```bash\n# via npm\nnpm install aliana-client\n\n# via yarn\nyarn add aliana-client\n\n# via pnpm\npnpm add aliana-client\n\n# via bun\nbun add aliana-client\n```\n\n---\n\n## ðŸŽ¯ Quick Start\n\n```typescript\nimport { LavalinkManager } from 'aliana-client';\n\nconst manager = new LavalinkManager({\n  nodes: [\n    {\n      host: 'localhost',\n      port: 2333,\n      password: 'youshallnotpass',\n      secure: false,\n    },\n  ],\n  sendPayload: (guildId, payload) => {\n    // Send payload to Discord gateway\n  },\n});\n\nmanager.on('ready', (node) => {\n  console.log(`Node ${node.identifier} is ready!`);\n});\n\nmanager.on('trackStart', (player, track) => {\n  console.log(`Now playing: ${track.info.title}`);\n});\n\nawait manager.init('YOUR_BOT_USER_ID');\n\nconst player = manager.createPlayer({\n  guildId: 'GUILD_ID',\n  voiceChannelId: 'VOICE_CHANNEL_ID',\n  textChannelId: 'TEXT_CHANNEL_ID',\n});\n\nawait player.connect();\n\nconst result = await manager.search('Never Gonna Give You Up', 'USER_ID');\nif (result.tracks.length) {\n  await player.queue.add(result.tracks[0]);\n  await player.play();\n}\n```\n\n---\n\n## ðŸ“– Documentation\n\nFull documentation with interactive examples coming soon!\n\n---\n\n## ðŸŽ¨ Audio Filters & Presets\n\n```typescript\n// Apply bass boost\nawait player.filters.setBassBoost(0.5);\n\n// Apply nightcore effect\nawait player.filters.setNightcore(true);\n\n// Apply 8D audio effect\nawait player.filters.set8D(true);\n\n// Echo & Reverb (requires lavalink-filter-plugin)\nawait player.filters.setEcho(1, 0.5);\nawait player.filters.setReverb();\n\n// High-pass, Low-pass, Normalization (requires LavaDSPX plugin)\nawait player.filters.setHighPass(100, 1.2);\nawait player.filters.setNormalization(0.75);\n\n// Audio output control\nawait player.filters.setAudioOutput('mono'); // mono, stereo, left, right\n\n// Custom equalizer\nawait player.filters.setEqualizer([\n  { band: 0, gain: 0.2 },\n  { band: 1, gain: 0.15 },\n]);\n```\n\n---\n\n## ðŸŽ¨ Music Card Generator\n\nGenerate beautiful visual music cards with real-time playback progress:\n\n```typescript\nimport { MusicCardGenerator } from 'aliana-client';\n\n// Generate card with current progress\nconst card = await MusicCardGenerator.generateCardWithProgress(\n  player.queue.current,  // Current track\n  player.position,        // Current position in milliseconds\n  {\n    backgroundColor: '#070707',\n    progressColor: '#1DB954',\n    nameColor: '#ffffff',\n    authorColor: '#99aab5',\n  },\n  'dynamic' // Theme: 'classic', 'classicPro', or 'dynamic'\n);\n\n// Send to Discord\nawait channel.send({ \n  files: [{ attachment: card, name: 'now-playing.png' }] \n});\n```\n\n**Features:**\n- ðŸŽ­ Three beautiful themes (classic, classicPro, dynamic)\n- ðŸ“Š Real-time progress bar\n- ðŸŽ¨ Customizable colors\n- ðŸ–¼ï¸ High-quality PNG output\n- âš¡ Fast generation (~100ms)\n\n---\n\n## ðŸ”§ Advanced Features\n\n### Flexible Queue Stores\n\n```typescript\n// Use default in-memory store\nconst player = manager.createPlayer({ ... });\n\n// Or bring your own Redis store\nimport { RedisStore } from './stores/RedisStore';\nconst player = manager.createPlayer({\n  queueStore: new RedisStore(redisClient),\n  ...\n});\n```\n\n### Client-Side Validation\n\n```typescript\nconst manager = new LavalinkManager({\n  nodes: [...],\n  validationOptions: {\n    allowedDomains: ['youtube.com', 'soundcloud.com'],\n    blockedDomains: ['malicious-site.com'],\n  },\n});\n```\n\n---\n\n## ðŸ¤ Contributing\n\nContributions, issues, and feature requests are welcome!\n\n---\n\n## ðŸ“ License\n\nThis project is [MIT](LICENSE) licensed.\n\n---\n\n## â­ Show Your Support\n\nGive a â­ï¸ if this project helped you!\n\n---\n\nBuilt with â¤ï¸ for the Discord music bot community\n","size_bytes":6102},"src/filters/FilterManager.ts":{"content":"import type { FilterData, EqualizerBand, ChannelMixFilter } from '../types';\nimport { FILTER_PRESETS, type PresetName } from './presets';\n\nexport class FilterManager {\n  private filters: FilterData = {};\n  private updateCallback: (filters: FilterData) => Promise<void>;\n\n  constructor(updateCallback: (filters: FilterData) => Promise<void>) {\n    this.updateCallback = updateCallback;\n  }\n\n  get current(): FilterData {\n    return { ...this.filters };\n  }\n\n  async setEqualizer(bands: EqualizerBand[]): Promise<void> {\n    this.filters.equalizer = bands;\n    await this.updateCallback(this.filters);\n  }\n\n  async setBassBoost(level: number = 0.5): Promise<void> {\n    const preset = FILTER_PRESETS.bassBoost(level);\n    this.filters.equalizer = preset.equalizer;\n    await this.updateCallback(this.filters);\n  }\n\n  async setNightcore(enable: boolean): Promise<void> {\n    if (enable) {\n      const preset = FILTER_PRESETS.nightcore();\n      this.filters.timescale = preset.timescale;\n      this.filters.tremolo = preset.tremolo;\n    } else {\n      delete this.filters.timescale;\n      delete this.filters.tremolo;\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setVaporwave(enable: boolean): Promise<void> {\n    if (enable) {\n      const preset = FILTER_PRESETS.vaporwave();\n      this.filters.timescale = preset.timescale;\n      this.filters.equalizer = preset.equalizer;\n      this.filters.tremolo = preset.tremolo;\n    } else {\n      delete this.filters.timescale;\n      delete this.filters.equalizer;\n      delete this.filters.tremolo;\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async set8D(enable: boolean): Promise<void> {\n    if (enable) {\n      const preset = FILTER_PRESETS.eightD();\n      this.filters.rotation = preset.rotation;\n    } else {\n      delete this.filters.rotation;\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setKaraoke(enable: boolean): Promise<void> {\n    if (enable) {\n      const preset = FILTER_PRESETS.karaoke();\n      this.filters.karaoke = preset.karaoke;\n    } else {\n      delete this.filters.karaoke;\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setPreset(preset: PresetName): Promise<void> {\n    const presetFunction = FILTER_PRESETS[preset];\n    if (typeof presetFunction !== 'function') {\n      throw new Error(`Invalid preset: ${preset}. Available presets: ${Object.keys(FILTER_PRESETS).join(', ')}`);\n    }\n    const presetFilters = presetFunction();\n    this.filters = { ...this.filters, ...presetFilters };\n    await this.updateCallback(this.filters);\n  }\n\n  async setTimescale(speed?: number, pitch?: number, rate?: number): Promise<void> {\n    if (!speed && !pitch && !rate) {\n      delete this.filters.timescale;\n    } else {\n      this.filters.timescale = { speed, pitch, rate };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setTremolo(frequency?: number, depth?: number): Promise<void> {\n    if (!frequency && !depth) {\n      delete this.filters.tremolo;\n    } else {\n      this.filters.tremolo = { frequency, depth };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setVibrato(frequency?: number, depth?: number): Promise<void> {\n    if (!frequency && !depth) {\n      delete this.filters.vibrato;\n    } else {\n      this.filters.vibrato = { frequency, depth };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setRotation(rotationHz?: number): Promise<void> {\n    if (!rotationHz) {\n      delete this.filters.rotation;\n    } else {\n      this.filters.rotation = { rotationHz };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setDistortion(options: {\n    sinOffset?: number;\n    sinScale?: number;\n    cosOffset?: number;\n    cosScale?: number;\n    tanOffset?: number;\n    tanScale?: number;\n    offset?: number;\n    scale?: number;\n  }): Promise<void> {\n    if (Object.keys(options).length === 0) {\n      delete this.filters.distortion;\n    } else {\n      this.filters.distortion = options;\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setChannelMix(options: {\n    leftToLeft?: number;\n    leftToRight?: number;\n    rightToLeft?: number;\n    rightToRight?: number;\n  }): Promise<void> {\n    if (Object.keys(options).length === 0) {\n      delete this.filters.channelMix;\n    } else {\n      this.filters.channelMix = options;\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setLowPass(smoothing?: number): Promise<void> {\n    if (!smoothing) {\n      delete this.filters.lowPass;\n    } else {\n      this.filters.lowPass = { smoothing };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async clearFilters(): Promise<void> {\n    this.filters = {};\n    await this.updateCallback(this.filters);\n  }\n\n  async setVolume(volume: number): Promise<void> {\n    this.filters.volume = Math.max(0, Math.min(5, volume));\n    await this.updateCallback(this.filters);\n  }\n\n  async setAudioOutput(type: 'mono' | 'stereo' | 'left' | 'right'): Promise<void> {\n    const audioOutputsData: Record<string, ChannelMixFilter> = {\n      mono: { leftToLeft: 0.5, leftToRight: 0.5, rightToLeft: 0.5, rightToRight: 0.5 },\n      stereo: { leftToLeft: 1, leftToRight: 0, rightToLeft: 0, rightToRight: 1 },\n      left: { leftToLeft: 1, leftToRight: 0, rightToLeft: 1, rightToRight: 0 },\n      right: { leftToLeft: 0, leftToRight: 1, rightToLeft: 0, rightToRight: 1 },\n    };\n    \n    if (type === 'stereo') {\n      delete this.filters.channelMix;\n    } else {\n      this.filters.channelMix = audioOutputsData[type];\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setEcho(delay?: number, decay?: number): Promise<void> {\n    if (!delay && !decay) {\n      if (this.filters.pluginFilters?.['lavalink-filter-plugin']) {\n        delete this.filters.pluginFilters['lavalink-filter-plugin'].echo;\n        if (Object.keys(this.filters.pluginFilters['lavalink-filter-plugin']).length === 0) {\n          delete this.filters.pluginFilters['lavalink-filter-plugin'];\n        }\n        if (Object.keys(this.filters.pluginFilters).length === 0) {\n          delete this.filters.pluginFilters;\n        }\n      }\n    } else {\n      if (!this.filters.pluginFilters) {\n        this.filters.pluginFilters = {};\n      }\n      if (!this.filters.pluginFilters['lavalink-filter-plugin']) {\n        this.filters.pluginFilters['lavalink-filter-plugin'] = {};\n      }\n      this.filters.pluginFilters['lavalink-filter-plugin'].echo = {\n        delay: delay ?? 1,\n        decay: decay ?? 0.5\n      };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setReverb(delays?: number[], gains?: number[]): Promise<void> {\n    if (!delays && !gains) {\n      if (this.filters.pluginFilters?.['lavalink-filter-plugin']) {\n        delete this.filters.pluginFilters['lavalink-filter-plugin'].reverb;\n        if (Object.keys(this.filters.pluginFilters['lavalink-filter-plugin']).length === 0) {\n          delete this.filters.pluginFilters['lavalink-filter-plugin'];\n        }\n        if (Object.keys(this.filters.pluginFilters).length === 0) {\n          delete this.filters.pluginFilters;\n        }\n      }\n    } else {\n      if (!this.filters.pluginFilters) {\n        this.filters.pluginFilters = {};\n      }\n      if (!this.filters.pluginFilters['lavalink-filter-plugin']) {\n        this.filters.pluginFilters['lavalink-filter-plugin'] = {};\n      }\n      this.filters.pluginFilters['lavalink-filter-plugin'].reverb = {\n        delays: delays ?? [0.037, 0.042, 0.048, 0.053],\n        gains: gains ?? [0.84, 0.83, 0.82, 0.81]\n      };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setHighPass(cutoffFrequency?: number, boostFactor?: number): Promise<void> {\n    if (!cutoffFrequency && !boostFactor) {\n      if (this.filters.pluginFilters) {\n        delete this.filters.pluginFilters['high-pass'];\n        if (Object.keys(this.filters.pluginFilters).length === 0) {\n          delete this.filters.pluginFilters;\n        }\n      }\n    } else {\n      if (!this.filters.pluginFilters) {\n        this.filters.pluginFilters = {};\n      }\n      this.filters.pluginFilters['high-pass'] = {\n        cutoffFrequency: cutoffFrequency ?? 1475,\n        boostFactor: boostFactor ?? 1.0\n      };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setPluginLowPass(cutoffFrequency?: number, boostFactor?: number): Promise<void> {\n    if (!cutoffFrequency && !boostFactor) {\n      if (this.filters.pluginFilters) {\n        delete this.filters.pluginFilters['low-pass'];\n        if (Object.keys(this.filters.pluginFilters).length === 0) {\n          delete this.filters.pluginFilters;\n        }\n      }\n    } else {\n      if (!this.filters.pluginFilters) {\n        this.filters.pluginFilters = {};\n      }\n      this.filters.pluginFilters['low-pass'] = {\n        cutoffFrequency: cutoffFrequency ?? 284,\n        boostFactor: boostFactor ?? 1.0\n      };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  async setNormalization(maxAmplitude?: number): Promise<void> {\n    if (!maxAmplitude) {\n      if (this.filters.pluginFilters) {\n        delete this.filters.pluginFilters['normalization'];\n        if (Object.keys(this.filters.pluginFilters).length === 0) {\n          delete this.filters.pluginFilters;\n        }\n      }\n    } else {\n      if (!this.filters.pluginFilters) {\n        this.filters.pluginFilters = {};\n      }\n      this.filters.pluginFilters['normalization'] = {\n        maxAmplitude: maxAmplitude ?? 0.75\n      };\n    }\n    await this.updateCallback(this.filters);\n  }\n\n  setFilters(filters: FilterData): void {\n    this.filters = { ...filters };\n  }\n}\n","size_bytes":9578},"src/stores/RedisStoreAdapter.ts":{"content":"import type { QueueStore, QueueData } from '../types';\n\nexport interface RedisClient {\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string): Promise<void>;\n  del(key: string): Promise<void>;\n  exists(key: string): Promise<boolean>;\n}\n\nexport class RedisStoreAdapter implements QueueStore {\n  private client: RedisClient;\n  private keyPrefix: string;\n\n  constructor(client: RedisClient, keyPrefix: string = 'aliana:queue:') {\n    this.client = client;\n    this.keyPrefix = keyPrefix;\n  }\n\n  private getKey(guildId: string): string {\n    return `${this.keyPrefix}${guildId}`;\n  }\n\n  async get(guildId: string): Promise<QueueData | null> {\n    const data = await this.client.get(this.getKey(guildId));\n    return data ? JSON.parse(data) : null;\n  }\n\n  async set(guildId: string, data: QueueData): Promise<void> {\n    await this.client.set(this.getKey(guildId), JSON.stringify(data));\n  }\n\n  async delete(guildId: string): Promise<void> {\n    await this.client.del(this.getKey(guildId));\n  }\n\n  async has(guildId: string): Promise<boolean> {\n    return await this.client.exists(this.getKey(guildId));\n  }\n}\n","size_bytes":1128},"src/types/lavalink.ts":{"content":"export interface NodeOptions {\n  host: string;\n  port: number;\n  password: string;\n  secure?: boolean;\n  identifier?: string;\n  retryAmount?: number;\n  retryDelay?: number;\n  requestTimeout?: number;\n  resumeKey?: string;\n  resumeTimeout?: number;\n  sessionId?: string;\n  regions?: string[];\n}\n\nexport interface LavalinkManagerOptions {\n  nodes: NodeOptions[];\n  sendPayload: (guildId: string, payload: any) => void;\n  validationOptions?: ValidationOptions;\n  autoResume?: boolean;\n  clientId?: string;\n  defaultSearchPlatform?: SearchPlatform;\n  playerOptions?: DefaultPlayerOptions;\n}\n\nexport interface ValidationOptions {\n  allowedDomains?: string[];\n  blockedDomains?: string[];\n  allowedProtocols?: string[];\n  maxTrackLength?: number;\n  maxPlaylistSize?: number;\n}\n\nexport interface DefaultPlayerOptions {\n  autoPlay?: boolean;\n  volume?: number;\n  selfDeaf?: boolean;\n  selfMute?: boolean;\n  leaveOnEmpty?: boolean;\n  leaveOnEmptyDelay?: number;\n  leaveOnEnd?: boolean;\n  leaveOnEndDelay?: number;\n  leaveOnStop?: boolean;\n  leaveOnStopDelay?: number;\n  applyVolumeAsFilter?: boolean;\n  audioNormalizer?: boolean;\n}\n\nexport type SearchPlatform = 'youtube' | 'youtubemusic' | 'soundcloud' | 'spotify' | 'deezer' | 'applemusic' | 'yandex';\n\nexport interface Track {\n  encoded: string;\n  info: TrackInfo;\n  pluginInfo?: Record<string, any>;\n  userData?: Record<string, any>;\n}\n\nexport interface TrackInfo {\n  identifier: string;\n  isSeekable: boolean;\n  author: string;\n  length: number;\n  isStream: boolean;\n  position: number;\n  title: string;\n  uri?: string;\n  artworkUrl?: string;\n  isrc?: string;\n  sourceName: string;\n}\n\nexport interface UnresolvedTrack {\n  title: string;\n  author?: string;\n  duration?: number;\n  uri?: string;\n  requester?: any;\n  resolve?: () => Promise<Track | null>;\n}\n\nexport interface SearchResult {\n  loadType: 'track' | 'playlist' | 'search' | 'empty' | 'error';\n  data: Track[] | {\n    info: PlaylistInfo;\n    pluginInfo: Record<string, any>;\n    tracks: Track[];\n  };\n}\n\nexport interface PlaylistInfo {\n  name: string;\n  selectedTrack: number;\n}\n\nexport interface ExceptionInfo {\n  message: string;\n  severity: 'common' | 'suspicious' | 'fault';\n  cause: string;\n}\n\nexport interface VoiceState {\n  sessionId: string;\n  event: VoiceServerUpdate;\n}\n\nexport interface VoiceServerUpdate {\n  token: string;\n  guild_id: string;\n  endpoint: string;\n}\n\nexport interface PlayerUpdateInfo {\n  guildId: string;\n  state: {\n    time: number;\n    position: number;\n    connected: boolean;\n    ping: number;\n  };\n}\n\nexport interface PlayerState {\n  time: number;\n  position: number;\n  connected: boolean;\n  ping: number;\n}\n\nexport interface LavalinkPlayerVoice {\n  token: string;\n  endpoint: string;\n  sessionId: string;\n}\n\nexport interface LavalinkPlayer {\n  guildId: string;\n  track?: {\n    encoded: string;\n    info?: TrackInfo;\n  };\n  volume: number;\n  paused: boolean;\n  state: PlayerState;\n  voice: LavalinkPlayerVoice;\n  filters?: FilterData;\n}\n\nexport interface FilterData {\n  volume?: number;\n  equalizer?: EqualizerBand[];\n  karaoke?: KaraokeFilter;\n  timescale?: TimescaleFilter;\n  tremolo?: TremoloFilter;\n  vibrato?: VibratoFilter;\n  rotation?: RotationFilter;\n  distortion?: DistortionFilter;\n  channelMix?: ChannelMixFilter;\n  lowPass?: LowPassFilter;\n  pluginFilters?: Record<string, any>;\n}\n\nexport interface EqualizerBand {\n  band: number;\n  gain: number;\n}\n\nexport interface KaraokeFilter {\n  level?: number;\n  monoLevel?: number;\n  filterBand?: number;\n  filterWidth?: number;\n}\n\nexport interface TimescaleFilter {\n  speed?: number;\n  pitch?: number;\n  rate?: number;\n}\n\nexport interface TremoloFilter {\n  frequency?: number;\n  depth?: number;\n}\n\nexport interface VibratoFilter {\n  frequency?: number;\n  depth?: number;\n}\n\nexport interface RotationFilter {\n  rotationHz?: number;\n}\n\nexport interface DistortionFilter {\n  sinOffset?: number;\n  sinScale?: number;\n  cosOffset?: number;\n  cosScale?: number;\n  tanOffset?: number;\n  tanScale?: number;\n  offset?: number;\n  scale?: number;\n}\n\nexport interface ChannelMixFilter {\n  leftToLeft?: number;\n  leftToRight?: number;\n  rightToLeft?: number;\n  rightToRight?: number;\n}\n\nexport interface LowPassFilter {\n  smoothing?: number;\n}\n\nexport enum DestroyReasons {\n  NodeDestroy = 'NodeDestroy',\n  NodeReconnect = 'NodeReconnect',\n  LavalinkNoVoice = 'LavalinkNoVoice',\n  NodeDeleted = 'NodeDeleted',\n  PlayerReconnect = 'PlayerReconnect',\n  Disconnected = 'Disconnected',\n  PlayerMovedChannels = 'PlayerMovedChannels',\n  ChannelDeleted = 'ChannelDeleted',\n  QueueEmpty = 'QueueEmpty',\n  TrackStuck = 'TrackStuck',\n  TrackError = 'TrackError',\n  Cleanup = 'Cleanup',\n}\n\nexport interface NodeStats {\n  players: number;\n  playingPlayers: number;\n  uptime: number;\n  memory: {\n    free: number;\n    used: number;\n    allocated: number;\n    reservable: number;\n  };\n  cpu: {\n    cores: number;\n    systemLoad: number;\n    lavalinkLoad: number;\n  };\n  frameStats?: {\n    sent: number;\n    nulled: number;\n    deficit: number;\n  };\n}\n\nexport interface LavalinkNodeInfo {\n  version: {\n    semver: string;\n    major: number;\n    minor: number;\n    patch: number;\n    preRelease?: string;\n  };\n  buildTime: number;\n  git: {\n    branch: string;\n    commit: string;\n    commitTime: number;\n  };\n  jvm: string;\n  lavaplayer: string;\n  sourceManagers: string[];\n  filters: string[];\n  plugins: PluginInfo[];\n}\n\nexport interface PluginInfo {\n  name: string;\n  version: string;\n}\n","size_bytes":5453},"src/structures/Node.ts":{"content":"import WebSocket from 'ws';\nimport { EventEmitter } from 'events';\nimport type { NodeOptions, NodeStats, LavalinkNodeInfo } from '../types';\n\ninterface ProcessedNodeOptions extends Omit<Required<NodeOptions>, 'resumeKey' | 'sessionId'> {\n  resumeKey?: string;\n  sessionId?: string;\n}\n\nexport class Node extends EventEmitter {\n  public identifier: string;\n  public options: ProcessedNodeOptions;\n  public stats: NodeStats | null = null;\n  public info: LavalinkNodeInfo | null = null;\n  public sessionId: string | null = null;\n  \n  private ws: WebSocket | null = null;\n  private reconnectTimeout: NodeJS.Timeout | null = null;\n  private reconnectAttempts = 0;\n  private connected = false;\n  private clientId: string | null = null;\n\n  constructor(options: NodeOptions) {\n    super();\n    \n    this.identifier = options.identifier || `${options.host}:${options.port}`;\n    this.options = {\n      host: options.host,\n      port: options.port,\n      password: options.password,\n      secure: options.secure ?? false,\n      identifier: this.identifier,\n      retryAmount: options.retryAmount ?? 5,\n      retryDelay: options.retryDelay ?? 30000,\n      requestTimeout: options.requestTimeout ?? 10000,\n      resumeKey: options.resumeKey,\n      resumeTimeout: options.resumeTimeout ?? 60,\n      sessionId: options.sessionId,\n      regions: options.regions || [],\n    };\n    \n    if (options.sessionId) {\n      this.sessionId = options.sessionId;\n    }\n  }\n\n  get isConnected(): boolean {\n    return this.connected && this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  get address(): string {\n    return `${this.options.host}:${this.options.port}`;\n  }\n\n  get wsAddress(): string {\n    const protocol = this.options.secure ? 'wss' : 'ws';\n    return `${protocol}://${this.address}/v4/websocket`;\n  }\n\n  get restAddress(): string {\n    const protocol = this.options.secure ? 'https' : 'http';\n    return `${protocol}://${this.address}/v4`;\n  }\n\n  async connect(clientId: string, resumeKey?: string): Promise<void> {\n    if (this.isConnected) return;\n\n    this.clientId = clientId;\n\n    const headers: Record<string, string> = {\n      'Authorization': this.options.password,\n      'User-Id': clientId,\n      'Client-Name': 'Aliana-client/1.0.0',\n    };\n\n    const sessionKey = resumeKey || this.options.resumeKey;\n    if (sessionKey && this.sessionId) {\n      headers['Session-Id'] = this.sessionId;\n    }\n\n    this.ws = new WebSocket(this.wsAddress, { headers });\n\n    this.ws.on('open', this.onOpen.bind(this));\n    this.ws.on('message', this.onMessage.bind(this));\n    this.ws.on('error', this.onError.bind(this));\n    this.ws.on('close', this.onClose.bind(this));\n  }\n\n  private async onOpen(): Promise<void> {\n    this.connected = true;\n    this.reconnectAttempts = 0;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    this.emit('connect');\n  }\n\n  private async configureResuming(): Promise<void> {\n    if (!this.sessionId || !this.options.resumeKey) return;\n    \n    const { request } = await import('undici');\n    await request(`${this.restAddress}/sessions/${this.sessionId}`, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': this.options.password,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        resuming: true,\n        timeout: this.options.resumeTimeout,\n      }),\n    });\n  }\n\n  private async onMessage(data: WebSocket.Data): Promise<void> {\n    try {\n      const payload = JSON.parse(data.toString());\n      this.emit('raw', payload);\n\n      switch (payload.op) {\n        case 'ready':\n          this.sessionId = payload.sessionId || null;\n          this.info = null;\n          await this.fetchInfo();\n          \n          if (this.options.resumeKey && this.sessionId && payload.resumed === false) {\n            try {\n              await this.configureResuming();\n            } catch (error) {\n              console.error('Failed to configure session resuming:', error);\n            }\n          }\n          \n          this.emit('ready', payload);\n          break;\n        case 'stats':\n          this.stats = payload;\n          this.emit('stats', payload);\n          break;\n        case 'event':\n          this.emit('event', payload);\n          break;\n        case 'playerUpdate':\n          this.emit('playerUpdate', payload);\n          break;\n      }\n    } catch (error) {\n      this.emit('error', error as Error);\n    }\n  }\n\n  private onError(error: Error): void {\n    this.emit('error', error);\n  }\n\n  private onClose(_code: number, reason: Buffer): void {\n    this.connected = false;\n    const reasonStr = reason.toString() || 'Unknown reason';\n    this.emit('disconnect', reasonStr);\n\n    if (this.reconnectAttempts < this.options.retryAmount) {\n      this.reconnectAttempts++;\n      this.reconnectTimeout = setTimeout(async () => {\n        this.emit('reconnecting');\n        try {\n          if (!this.clientId) {\n            console.error('Cannot reconnect: clientId not stored');\n            return;\n          }\n          await this.connect(this.clientId, this.options.resumeKey);\n        } catch (error) {\n          console.error('Reconnection failed:', error);\n        }\n      }, this.options.retryDelay);\n    } else {\n      console.warn(`Node ${this.identifier} failed to reconnect after ${this.options.retryAmount} attempts`);\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (!this.ws) return;\n    \n    this.connected = false;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    \n    this.ws.close(1000, 'Disconnect');\n    this.ws.removeAllListeners();\n    this.ws = null;\n  }\n\n  send(payload: any): void {\n    if (!this.isConnected) {\n      throw new Error(`Node ${this.identifier} is not connected`);\n    }\n    console.log(`ðŸ“¤ Sending to Lavalink:`, JSON.stringify(payload));\n    this.ws!.send(JSON.stringify(payload));\n  }\n\n  async fetchInfo(): Promise<LavalinkNodeInfo> {\n    const { request } = await import('undici');\n    const response = await request(`${this.restAddress}/info`, {\n      headers: {\n        'Authorization': this.options.password,\n      },\n    });\n    \n    this.info = await response.body.json() as LavalinkNodeInfo;\n    return this.info;\n  }\n\n  async request<T = any>(endpoint: string, options: any = {}): Promise<T> {\n    const { request } = await import('undici');\n    const response = await request(`${this.restAddress}${endpoint}`, {\n      ...options,\n      headers: {\n        'Authorization': this.options.password,\n        ...options.headers,\n      },\n    });\n\n    return await response.body.json() as T;\n  }\n\n  async updatePlayer(options: {\n    guildId: string;\n    playerOptions?: {\n      track?: { encoded?: string; identifier?: string; userData?: any };\n      position?: number;\n      endTime?: number;\n      volume?: number;\n      paused?: boolean;\n      filters?: any;\n      voice?: {\n        token: string;\n        endpoint: string;\n        sessionId: string;\n      };\n    };\n    noReplace?: boolean;\n  }): Promise<any> {\n    if (!this.sessionId) {\n      throw new Error('No session ID available');\n    }\n\n    const { request } = await import('undici');\n    const body: any = {\n      ...options.playerOptions,\n    };\n\n    if (options.noReplace !== undefined) {\n      body.noReplace = options.noReplace;\n    }\n\n    console.log(`ðŸ“¤ REST updatePlayer:`, JSON.stringify(body));\n\n    const response = await request(\n      `${this.restAddress}/sessions/${this.sessionId}/players/${options.guildId}?noReplace=${options.noReplace || false}`,\n      {\n        method: 'PATCH',\n        headers: {\n          'Authorization': this.options.password,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(body),\n      }\n    );\n\n    return await response.body.json();\n  }\n}\n","size_bytes":7853},"src/types/events.ts":{"content":"import type { Track, NodeStats, DestroyReasons } from './lavalink';\nimport type { Player } from '../structures/Player';\nimport type { Node } from '../structures/Node';\n\nexport interface ManagerEvents {\n  ready: [node: Node];\n  nodeConnect: [node: Node];\n  nodeReconnect: [node: Node];\n  nodeDisconnect: [node: Node, reason: string];\n  nodeError: [node: Node, error: Error];\n  nodeRaw: [node: Node, payload: any];\n  \n  playerCreate: [player: Player];\n  playerDestroy: [player: Player, reason: DestroyReasons];\n  playerMove: [player: Player, oldChannel: string, newChannel: string];\n  playerDisconnect: [player: Player, oldChannel: string];\n  \n  trackStart: [player: Player, track: Track];\n  trackEnd: [player: Player, track: Track, reason: TrackEndReason];\n  trackStuck: [player: Player, track: Track, thresholdMs: number];\n  trackError: [player: Player, track: Track, error: TrackException];\n  \n  autoPlayTrack: [player: Player, track: Track];\n  queueEnd: [player: Player];\n  \n  socketClosed: [player: Player, code: number, reason: string, byRemote: boolean];\n}\n\nexport type TrackEndReason = \n  | 'finished'\n  | 'loadFailed'\n  | 'stopped'\n  | 'replaced'\n  | 'cleanup';\n\nexport interface TrackException {\n  message: string;\n  severity: 'common' | 'suspicious' | 'fault';\n  cause: string;\n}\n\nexport interface NodeEvents {\n  raw: [payload: any];\n  disconnect: [reason: string];\n  reconnecting: [];\n  connect: [];\n  error: [error: Error];\n  stats: [stats: NodeStats];\n}\n\nexport interface WebSocketClosedEvent {\n  guildId: string;\n  code: number;\n  reason: string;\n  byRemote: boolean;\n}\n\nexport interface TrackStartEvent {\n  guildId: string;\n  track: Track;\n}\n\nexport interface TrackEndEvent {\n  guildId: string;\n  track: Track;\n  reason: TrackEndReason;\n}\n\nexport interface TrackExceptionEvent {\n  guildId: string;\n  track: Track;\n  exception: TrackException;\n}\n\nexport interface TrackStuckEvent {\n  guildId: string;\n  track: Track;\n  thresholdMs: number;\n}\n","size_bytes":1955},"src/structures/Player.ts":{"content":"import { EventEmitter } from 'events';\nimport type { \n  PlayerOptions, \n  ConnectOptions, \n  PlayOptions, \n  VoiceState, \n  FilterData,\n  QueueStore \n} from '../types';\nimport { DestroyReasons } from '../types';\nimport { Queue } from './Queue';\nimport { Track } from './Track';\nimport { Node } from './Node';\nimport { FilterManager } from '../filters/FilterManager';\nimport { AudioNormalizer } from '../utils/AudioNormalizer';\nimport { MemoryStore } from '../stores/MemoryStore';\n\nexport class Player extends EventEmitter {\n  public readonly guildId: string;\n  public voiceChannelId: string;\n  public textChannelId?: string;\n  public node: Node;\n  public queue: Queue;\n  public filters: FilterManager;\n  \n  private normalizer: AudioNormalizer;\n  private _volume: number = 100;\n  private _paused: boolean = false;\n  private _playing: boolean = false;\n  private _connected: boolean = false;\n  private _position: number = 0;\n  private _ping: number = 0;\n  private _autoPlay: boolean = false;\n  private _inAutoPlaySession: boolean = false;\n  private _lastPlayedTrack: Track | null = null;\n  private voiceState: Partial<VoiceState> = {};\n  private sendPayload: (guildId: string, payload: any) => void;\n  private selfDeaf: boolean;\n  private selfMute: boolean;\n  \n  constructor(options: PlayerOptions, node: Node, sendPayload: (guildId: string, payload: any) => void, store?: QueueStore) {\n    super();\n    \n    this.guildId = options.guildId;\n    this.voiceChannelId = options.voiceChannelId;\n    this.textChannelId = options.textChannelId;\n    this.node = node;\n    this.sendPayload = sendPayload;\n    this.selfDeaf = options.selfDeaf ?? true;\n    this.selfMute = options.selfMute ?? false;\n    \n    const queueStore = store || new MemoryStore();\n    this.queue = new Queue(this.guildId, queueStore);\n    \n    this.normalizer = new AudioNormalizer(\n      options.audioNormalizer ?? true,\n      1.0\n    );\n    \n    this.filters = new FilterManager(this.updateFilters.bind(this));\n    \n    if (options.volume !== undefined) {\n      this._volume = options.volume;\n    }\n    \n    this.queue.initialize().catch(err => {\n      console.error(`Failed to initialize queue for ${this.guildId}:`, err);\n    });\n  }\n\n  get volume(): number {\n    return this._volume;\n  }\n\n  get paused(): boolean {\n    return this._paused;\n  }\n\n  get playing(): boolean {\n    return this._playing;\n  }\n\n  get connected(): boolean {\n    return this._connected;\n  }\n\n  get position(): number {\n    return this._position;\n  }\n\n  get ping(): number {\n    return this._ping;\n  }\n\n  get autoPlay(): boolean {\n    return this._autoPlay;\n  }\n\n  setAutoPlay(enabled: boolean): void {\n    this._autoPlay = enabled;\n    if (!enabled) {\n      this._inAutoPlaySession = false;\n    }\n  }\n\n  get inAutoPlaySession(): boolean {\n    return this._inAutoPlaySession;\n  }\n\n  setAutoPlaySession(active: boolean): void {\n    this._inAutoPlaySession = active;\n  }\n\n  get lastPlayedTrack(): Track | null {\n    return this._lastPlayedTrack;\n  }\n\n  setLastPlayedTrack(track: Track | null): void {\n    this._lastPlayedTrack = track;\n  }\n\n  async connect(options: ConnectOptions = {}): Promise<void> {\n    if (!this.voiceChannelId) {\n      throw new Error('Cannot connect: voiceChannelId is not set');\n    }\n    \n    if (!this.sendPayload) {\n      throw new Error('Cannot connect: sendPayload callback is not configured');\n    }\n    \n    const selfDeaf = options.deaf ?? this.selfDeaf;\n    const selfMute = options.mute ?? this.selfMute;\n    \n    this.sendPayload(this.guildId, {\n      op: 4,\n      d: {\n        guild_id: this.guildId,\n        channel_id: this.voiceChannelId,\n        self_mute: selfMute,\n        self_deaf: selfDeaf,\n      },\n    });\n    \n    this.voiceState = {\n      sessionId: undefined,\n      event: undefined,\n    };\n    \n    this.emit('connectionUpdate', 'CONNECTING');\n    this._connected = true;\n  }\n  \n  async waitForQueueReady(): Promise<void> {\n    await this.queue.initialize();\n  }\n\n  setVoiceState(data: Partial<VoiceState>): void {\n    this.voiceState = { ...this.voiceState, ...data };\n    \n    if (this.voiceState.sessionId && this.voiceState.event) {\n      this.sendVoiceUpdate();\n    }\n  }\n\n  private async sendVoiceUpdate(): Promise<void> {\n    if (!this.voiceState.sessionId || !this.voiceState.event) return;\n    \n    await this.node.updatePlayer({\n      guildId: this.guildId,\n      playerOptions: {\n        voice: {\n          token: this.voiceState.event.token,\n          endpoint: this.voiceState.event.endpoint,\n          sessionId: this.voiceState.sessionId,\n        },\n      },\n    });\n  }\n\n  async play(options: PlayOptions = {}): Promise<void> {\n    await this.queue.initialize();\n    \n    if (!this.queue.current && this.queue.size === 0) {\n      throw new Error('Queue is empty');\n    }\n\n    let track = this.queue.current;\n    if (!track) {\n      track = await this.queue.next();\n      if (!track) throw new Error('No track to play');\n    }\n\n    const playerOptions: any = {\n      track: {\n        encoded: track.encoded,\n      },\n    };\n\n    if (options.startTime) playerOptions.position = options.startTime;\n    if (options.endTime) playerOptions.endTime = options.endTime;\n    if (options.pause !== undefined) playerOptions.paused = options.pause;\n    if (options.volume !== undefined) {\n      playerOptions.volume = this.normalizer.normalize(options.volume);\n      this._volume = options.volume;\n    }\n\n    await this.node.updatePlayer({\n      guildId: this.guildId,\n      noReplace: options.noReplace ?? false,\n      playerOptions,\n    });\n\n    this._playing = true;\n    this._paused = options.pause ?? false;\n  }\n\n  async stop(): Promise<void> {\n    await this.node.updatePlayer({\n      guildId: this.guildId,\n      playerOptions: {\n        track: { encoded: null as any },\n      },\n    });\n    \n    this._playing = false;\n    this._paused = false;\n    this._position = 0;\n  }\n\n  async pause(pause: boolean = true): Promise<void> {\n    await this.node.updatePlayer({\n      guildId: this.guildId,\n      playerOptions: {\n        paused: pause,\n      },\n    });\n    \n    this._paused = pause;\n  }\n\n  async resume(): Promise<void> {\n    await this.pause(false);\n  }\n\n  async seek(position: number): Promise<void> {\n    if (!this.queue.current) {\n      throw new Error('No track is currently playing');\n    }\n\n    await this.node.updatePlayer({\n      guildId: this.guildId,\n      playerOptions: {\n        position: Math.max(0, position),\n      },\n    });\n    \n    this._position = position;\n  }\n\n  async setVolume(volume: number): Promise<void> {\n    this._volume = Math.max(0, Math.min(1000, volume));\n    const normalizedVolume = this.normalizer.normalize(this._volume);\n    \n    await this.filters.setVolume(normalizedVolume / 100);\n  }\n\n  private async updateFilters(filters: FilterData): Promise<void> {\n    const normalizedFilters = this.normalizer.applyNormalization(\n      filters, \n      this._volume\n    );\n\n    await this.node.updatePlayer({\n      guildId: this.guildId,\n      playerOptions: {\n        filters: normalizedFilters,\n      },\n    });\n  }\n\n  async skip(): Promise<Track | null> {\n    await this.queue.initialize();\n    await this.stop();\n    const nextTrack = await this.queue.next();\n    \n    if (nextTrack) {\n      await this.play();\n      return nextTrack;\n    }\n    \n    return null;\n  }\n\n  async destroy(reason: DestroyReasons = DestroyReasons.Cleanup): Promise<void> {\n    const { request } = await import('undici');\n    await request(\n      `${this.node.restAddress}/sessions/${this.node.sessionId}/players/${this.guildId}`,\n      {\n        method: 'DELETE',\n        headers: {\n          'Authorization': this.node.options.password,\n        },\n      }\n    );\n\n    await this.queue.clear();\n    this._connected = false;\n    this._playing = false;\n    this._paused = false;\n    this._autoPlay = false;\n    \n    this.emit('destroyed', reason);\n    this.removeAllListeners();\n  }\n\n  updateState(state: any): void {\n    this._position = state.state.position || 0;\n    this._connected = state.state.connected;\n    this._ping = state.state.ping || 0;\n  }\n\n  setPlaying(playing: boolean): void {\n    this._playing = playing;\n  }\n}\n","size_bytes":8144},"tsup.config.ts":{"content":"import { defineConfig } from 'tsup';\n\nexport default defineConfig({\n  entry: ['src/index.ts'],\n  format: ['cjs', 'esm'],\n  dts: true,\n  splitting: false,\n  sourcemap: true,\n  clean: true,\n  minify: false,\n  target: 'es2022',\n  outDir: 'dist',\n  skipNodeModulesBundle: true,\n  treeshake: true,\n  keepNames: true,\n});\n","size_bytes":316},"src/utils/Validator.ts":{"content":"import type { ValidationOptions } from '../types';\n\nexport class Validator {\n  private options: ValidationOptions;\n\n  constructor(options: ValidationOptions = {}) {\n    this.options = {\n      allowedDomains: options.allowedDomains || [],\n      blockedDomains: options.blockedDomains || [],\n      allowedProtocols: options.allowedProtocols || ['http', 'https'],\n      maxTrackLength: options.maxTrackLength || 3600000,\n      maxPlaylistSize: options.maxPlaylistSize || 1000,\n    };\n  }\n\n  validateUrl(url: string): { valid: boolean; reason?: string } {\n    try {\n      const parsed = new URL(url);\n      \n      if (!this.options.allowedProtocols!.includes(parsed.protocol.replace(':', ''))) {\n        return { valid: false, reason: `Protocol ${parsed.protocol} not allowed` };\n      }\n\n      const hostname = parsed.hostname;\n\n      if (this.options.blockedDomains!.length > 0) {\n        for (const blocked of this.options.blockedDomains!) {\n          if (hostname.includes(blocked)) {\n            return { valid: false, reason: `Domain ${hostname} is blocked` };\n          }\n        }\n      }\n\n      if (this.options.allowedDomains!.length > 0) {\n        const allowed = this.options.allowedDomains!.some(domain => hostname.includes(domain));\n        if (!allowed) {\n          return { valid: false, reason: `Domain ${hostname} is not in allowed list` };\n        }\n      }\n\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, reason: 'Invalid URL format' };\n    }\n  }\n\n  validateTrackLength(length: number): { valid: boolean; reason?: string } {\n    if (length > this.options.maxTrackLength!) {\n      return { \n        valid: false, \n        reason: `Track length ${length}ms exceeds maximum ${this.options.maxTrackLength}ms` \n      };\n    }\n    return { valid: true };\n  }\n\n  validatePlaylistSize(size: number): { valid: boolean; reason?: string } {\n    if (size > this.options.maxPlaylistSize!) {\n      return { \n        valid: false, \n        reason: `Playlist size ${size} exceeds maximum ${this.options.maxPlaylistSize}` \n      };\n    }\n    return { valid: true };\n  }\n\n  sanitizeInput(input: string): string {\n    return input\n      .replace(/[<>]/g, '')\n      .trim()\n      .slice(0, 1000);\n  }\n}\n","size_bytes":2233},"src/utils/AudioNormalizer.ts":{"content":"import type { EqualizerBand, FilterData } from '../types';\n\nexport class AudioNormalizer {\n  private targetVolume: number;\n  private enabled: boolean;\n\n  constructor(enabled: boolean = true, targetVolume: number = 1.0) {\n    this.enabled = enabled;\n    this.targetVolume = Math.max(0.0, Math.min(5.0, targetVolume));\n  }\n\n  isEnabled(): boolean {\n    return this.enabled;\n  }\n\n  setEnabled(enabled: boolean): void {\n    this.enabled = enabled;\n  }\n\n  normalize(currentVolume: number): number {\n    if (!this.enabled) return currentVolume;\n\n    const normalized = currentVolume * this.targetVolume;\n    return Math.max(0, Math.min(1000, normalized));\n  }\n\n  getRecommendedEqualizer(trackLoudness?: number): EqualizerBand[] {\n    if (!this.enabled || !trackLoudness) {\n      return [];\n    }\n\n    const adjustment = this.calculateAdjustment(trackLoudness);\n    \n    return [\n      { band: 0, gain: adjustment * 0.1 },\n      { band: 1, gain: adjustment * 0.08 },\n      { band: 2, gain: adjustment * 0.05 },\n      { band: 3, gain: adjustment * 0.03 },\n      { band: 4, gain: adjustment * 0.02 },\n    ];\n  }\n\n  private calculateAdjustment(loudness: number): number {\n    const targetLoudness = -14;\n    const difference = targetLoudness - loudness;\n    \n    return Math.max(-0.25, Math.min(0.25, difference / 10));\n  }\n\n  applyNormalization(filters: FilterData, currentVolume: number): FilterData {\n    if (!this.enabled) return filters;\n\n    const normalizedFilters = { ...filters };\n    \n    if (!normalizedFilters.volume) {\n      normalizedFilters.volume = this.normalize(currentVolume) / 100;\n    }\n\n    return normalizedFilters;\n  }\n}\n","size_bytes":1635},"src/types/index.ts":{"content":"export * from './lavalink';\nexport * from './events';\n\nexport interface QueueStore {\n  get(guildId: string): Promise<QueueData | null>;\n  set(guildId: string, data: QueueData): Promise<void>;\n  delete(guildId: string): Promise<void>;\n  has(guildId: string): Promise<boolean>;\n}\n\nexport interface QueueData {\n  current: any;\n  tracks: any[];\n  previous: any[];\n}\n\nexport interface PlayerOptions {\n  guildId: string;\n  voiceChannelId: string;\n  textChannelId?: string;\n  selfDeaf?: boolean;\n  selfMute?: boolean;\n  volume?: number;\n  audioNormalizer?: boolean;\n  queueStore?: QueueStore;\n  node?: string;\n}\n\nexport interface ConnectOptions {\n  mute?: boolean;\n  deaf?: boolean;\n}\n\nexport interface PlayOptions {\n  startTime?: number;\n  endTime?: number;\n  noReplace?: boolean;\n  pause?: boolean;\n  volume?: number;\n}\n\nexport interface SearchQuery {\n  query: string;\n  source?: string;\n}\n","size_bytes":885},"GETTING_STARTED.md":{"content":"# Getting Started with Aliana-client\n\n## Installation\n\n```bash\nnpm install aliana-client\n```\n\n## Prerequisites\n\n- Node.js 18.0.0 or higher\n- A Lavalink v4 server running\n- Discord bot with voice permissions\n\n## Quick Setup\n\n### 1. Initialize the Manager\n\n```typescript\nimport { LavalinkManager } from 'aliana-client';\n\nconst manager = new LavalinkManager({\n  nodes: [\n    {\n      host: 'localhost',\n      port: 2333,\n      password: 'youshallnotpass',\n      secure: false,\n      identifier: 'main-node',\n    },\n  ],\n  sendPayload: (guildId, payload) => {\n    // Send payload to Discord gateway\n    // Example with discord.js:\n    const guild = client.guilds.cache.get(guildId);\n    if (guild) guild.shard.send(payload);\n  },\n});\n```\n\n### 2. Set Up Event Listeners\n\n```typescript\nmanager.on('ready', (node) => {\n  console.log(`Node ${node.identifier} is ready!`);\n});\n\nmanager.on('trackStart', (player, track) => {\n  console.log(`Now playing: ${track.title} by ${track.author}`);\n});\n\nmanager.on('trackEnd', (player, track, reason) => {\n  console.log(`Track ended: ${reason}`);\n});\n\nmanager.on('queueEnd', (player) => {\n  console.log('Queue is empty');\n});\n\nmanager.on('nodeError', (node, error) => {\n  console.error(`Node ${node.identifier} error:`, error);\n});\n```\n\n### 3. Initialize the Manager\n\n```typescript\nawait manager.init('YOUR_BOT_USER_ID');\n```\n\n### 4. Create a Player\n\n```typescript\nconst player = manager.createPlayer({\n  guildId: 'GUILD_ID',\n  voiceChannelId: 'VOICE_CHANNEL_ID',\n  textChannelId: 'TEXT_CHANNEL_ID',\n  volume: 100,\n  selfDeaf: true,\n});\n\nawait player.connect();\n```\n\n### 5. Search and Play Music\n\n```typescript\nconst result = await manager.search('Never Gonna Give You Up', 'USER_ID');\n\nif (result.tracks.length > 0) {\n  await player.queue.add(result.tracks[0]);\n  await player.play();\n}\n```\n\n## Voice State Updates\n\nYou need to forward voice state updates from Discord to Aliana-client:\n\n### With discord.js\n\n```typescript\nclient.on('voiceStateUpdate', (oldState, newState) => {\n  manager.updateVoiceState(newState);\n});\n\nclient.ws.on('VOICE_SERVER_UPDATE' as any, (data: any) => {\n  manager.updateVoiceServer(data);\n});\n```\n\n## Configuration Options\n\n### LavalinkManager Options\n\n```typescript\ninterface LavalinkManagerOptions {\n  nodes: NodeOptions[];\n  sendPayload: (guildId: string, payload: any) => void;\n  validationOptions?: ValidationOptions;\n  autoResume?: boolean;\n  clientId?: string;\n  defaultSearchPlatform?: SearchPlatform;\n  playerOptions?: DefaultPlayerOptions;\n}\n```\n\n### Validation Options\n\n```typescript\nconst manager = new LavalinkManager({\n  nodes: [...],\n  sendPayload: ...,\n  validationOptions: {\n    allowedDomains: ['youtube.com', 'soundcloud.com'],\n    blockedDomains: ['malicious-site.com'],\n    allowedProtocols: ['http', 'https'],\n    maxTrackLength: 3600000, // 1 hour in ms\n    maxPlaylistSize: 1000,\n  },\n});\n```\n\n### Player Options\n\n```typescript\nconst player = manager.createPlayer({\n  guildId: 'GUILD_ID',\n  voiceChannelId: 'VOICE_CHANNEL_ID',\n  textChannelId: 'TEXT_CHANNEL_ID',\n  volume: 100,\n  selfDeaf: true,\n  selfMute: false,\n  audioNormalizer: true,\n});\n```\n\n## Search Platforms\n\nSupported platforms:\n- `youtube` (default)\n- `youtubemusic`\n- `soundcloud`\n- `spotify`\n- `deezer`\n- `applemusic`\n- `yandex`\n\n```typescript\nconst result = await manager.search('song name', 'USER_ID', 'spotify');\n```\n\n## Next Steps\n\n- [API Reference](./API_REFERENCE.md)\n- [Examples](./EXAMPLES.md)\n- [Audio Filters Guide](./README.md#-audio-filters--presets)\n","size_bytes":3511},"replit.md":{"content":"# Aliana-client\n\n## Overview\nAliana-client is a premium TypeScript Lavalink v4 client package designed to be superior to existing solutions. It offers enhanced audio quality, advanced features, comprehensive documentation, and developer-friendly APIs.\n\n## Project Status\n**Status**: âœ… Production Ready - All Core Features Implemented  \n**Version**: 1.0.0  \n**Last Updated**: November 17, 2025\n\n## Goals\n- Create the most feature-rich Lavalink v4 client available\n- Provide superior audio quality with built-in normalizer and advanced filters\n- Offer flexible architecture with pluggable components\n- Deliver comprehensive documentation with interactive examples\n- Ensure type-safety with full TypeScript support\n\n## Recent Changes\n- **2025-11-17**: âœ… **Complete Production Implementation + Documentation Website**\n  - Core Lavalink v4 integration with WebSocket & REST API\n  - Advanced queue system with persistence and proper initialization locking\n  - Comprehensive filter system with AudioNormalizer for superior quality\n  - **Smart Autoplay**: Intelligent track recommendations that play different, similar songs\n  - **Music Card Generator**: Built-in musicard integration for visual music cards (EXCLUSIVE FEATURE)\n  - **Advanced Filters**: Echo, reverb, high-pass, low-pass, normalization, audio output control\n  - **Session Resuming**: Automatic session recovery on reconnection\n  - Smart unresolved track handling with caching and error handling\n  - Client & server-side validation for URLs, playlists, and tracks\n  - Complete voice state integration with Discord gateway\n  - All critical race conditions resolved with proper async flow\n  - **Full Documentation Website**: Interactive HTML documentation with animations, search, code highlighting\n    - Unique features section highlighting what makes Aliana-Client different\n    - Music cards tutorial section (exclusive to Aliana-Client)\n    - Animated particles background, smooth transitions, hover effects\n    - Dark theme with gradient animations\n    - Mobile-responsive design\n  - Test bot updated with all new features\n\n## Project Architecture\n\n### Core Components\n1. **LavalinkManager**: Central manager for node connections and players\n2. **Player**: Advanced audio player with quality settings\n3. **Queue**: Flexible queue system with pluggable stores\n4. **Filters**: Comprehensive audio filter system with presets\n5. **Node**: WebSocket connection handler for Lavalink nodes\n6. **Types**: Complete TypeScript type definitions\n\n### Directory Structure\n```\nsrc/\nâ”œâ”€â”€ index.ts                 # Main entry point\nâ”œâ”€â”€ structures/              # Core classes\nâ”‚   â”œâ”€â”€ LavalinkManager.ts\nâ”‚   â”œâ”€â”€ Player.ts\nâ”‚   â”œâ”€â”€ Queue.ts\nâ”‚   â”œâ”€â”€ Node.ts\nâ”‚   â””â”€â”€ Track.ts\nâ”œâ”€â”€ filters/                 # Audio filters\nâ”‚   â”œâ”€â”€ FilterManager.ts\nâ”‚   â””â”€â”€ presets.ts\nâ”œâ”€â”€ stores/                  # Queue stores\nâ”‚   â”œâ”€â”€ MemoryStore.ts\nâ”‚   â””â”€â”€ RedisStoreAdapter.ts\nâ”œâ”€â”€ utils/                   # Utilities\nâ”‚   â”œâ”€â”€ Validator.ts\nâ”‚   â””â”€â”€ AudioNormalizer.ts\nâ””â”€â”€ types/                   # TypeScript types\n    â”œâ”€â”€ lavalink.ts\n    â”œâ”€â”€ events.ts\n    â””â”€â”€ index.ts\n```\n\n## Key Features\n- ðŸ’¯ Native Lavalink v4 support with full plugin ecosystem\n- ðŸŽ¨ **EXCLUSIVE**: Built-in music card generator with musicard integration\n- âœ¨ Enhanced audio quality with built-in normalizer\n- ðŸŽšï¸ Advanced filters: bass boost, nightcore, vaporwave, 8D audio\n- ðŸ”„ Flexible queue stores (in-memory, Redis)\n- âš¡ 10x faster playlist loading with intelligent caching\n- ðŸŽ¶ Smart unresolved track handling with lazy loading\n- ðŸ›¡ï¸ Client and server-side validation\n- ðŸ¤– Automatic error handling and recovery\n- ðŸ“– Comprehensive interactive documentation website\n\n## Tech Stack\n- **Language**: TypeScript 5.3+\n- **Build**: tsup (fast bundler)\n- **Runtime**: Node.js 18+\n- **Dependencies**: ws, undici, musicard (exclusive feature)\n- **Documentation**: Custom HTML/CSS/JS website with animations\n\n## Development Workflow\n- `npm run dev`: Watch mode for development\n- `npm run build`: Production build\n- `npm run type-check`: TypeScript validation\n- `npm run docs:dev`: Documentation dev server\n\n## User Preferences\nNone specified yet.\n","size_bytes":4303},"src/structures/Track.ts":{"content":"import type { Track as LavalinkTrack, UnresolvedTrack, TrackInfo } from '../types';\n\nexport class Track implements LavalinkTrack {\n  encoded: string;\n  info: TrackInfo;\n  pluginInfo?: Record<string, any>;\n  userData?: Record<string, any>;\n  requester?: any;\n\n  constructor(data: LavalinkTrack, requester?: any) {\n    this.encoded = data.encoded;\n    this.info = data.info;\n    this.pluginInfo = data.pluginInfo;\n    this.userData = data.userData || {};\n    this.requester = requester;\n  }\n\n  get title(): string {\n    return this.info.title;\n  }\n\n  get author(): string {\n    return this.info.author;\n  }\n\n  get duration(): number {\n    return this.info.length;\n  }\n\n  get uri(): string | undefined {\n    return this.info.uri;\n  }\n\n  get thumbnail(): string | undefined {\n    return this.info.artworkUrl;\n  }\n\n  get identifier(): string {\n    return this.info.identifier;\n  }\n\n  get isStream(): boolean {\n    return this.info.isStream;\n  }\n\n  get isSeekable(): boolean {\n    return this.info.isSeekable;\n  }\n\n  get sourceName(): string {\n    return this.info.sourceName;\n  }\n\n  toJSON(): LavalinkTrack {\n    return {\n      encoded: this.encoded,\n      info: this.info,\n      pluginInfo: this.pluginInfo,\n      userData: this.userData,\n    };\n  }\n\n  clone(): Track {\n    return new Track(this.toJSON(), this.requester);\n  }\n}\n\nexport class UnresolvedTrackImpl implements UnresolvedTrack {\n  title: string;\n  author?: string;\n  duration?: number;\n  uri?: string;\n  requester?: any;\n  private resolveFunc?: () => Promise<any>;\n  private resolved: Track | null = null;\n  private resolutionAttempted: boolean = false;\n  private resolutionError: Error | null = null;\n\n  constructor(data: UnresolvedTrack) {\n    this.title = data.title;\n    this.author = data.author;\n    this.duration = data.duration;\n    this.uri = data.uri;\n    this.requester = data.requester;\n    this.resolveFunc = data.resolve as any;\n  }\n\n  async resolve(): Promise<Track | null> {\n    if (this.resolved) return this.resolved;\n    \n    if (this.resolutionAttempted) {\n      if (this.resolutionError) {\n        throw this.resolutionError;\n      }\n      const notFoundError = new Error(`Track \"${this.title}\" could not be resolved: no matching track found`);\n      this.resolutionError = notFoundError;\n      throw notFoundError;\n    }\n    \n    this.resolutionAttempted = true;\n    \n    if (!this.resolveFunc) {\n      const noResolverError = new Error(`Track \"${this.title}\" has no resolver function configured`);\n      this.resolutionError = noResolverError;\n      throw noResolverError;\n    }\n    \n    try {\n      const track = await this.resolveFunc();\n      if (track) {\n        if (track instanceof Track) {\n          this.resolved = track;\n        } else if (track.encoded && track.info) {\n          this.resolved = new Track(track, this.requester);\n        } else {\n          throw new Error(`Invalid track data returned from resolver for \"${this.title}\": missing encoded or info`);\n        }\n        return this.resolved;\n      }\n      const notFoundError = new Error(`Track \"${this.title}\" could not be resolved: resolver returned null/undefined`);\n      this.resolutionError = notFoundError;\n      throw notFoundError;\n    } catch (error) {\n      this.resolutionError = error instanceof Error ? error : new Error(String(error));\n      throw this.resolutionError;\n    }\n  }\n\n  isResolved(): boolean {\n    return this.resolved !== null;\n  }\n\n  getResolved(): Track | null {\n    return this.resolved;\n  }\n  \n  getResolutionError(): Error | null {\n    return this.resolutionError;\n  }\n}\n","size_bytes":3559},"src/structures/LavalinkManager.ts":{"content":"import { EventEmitter } from 'events';\nimport type {\n  LavalinkManagerOptions,\n  PlayerOptions,\n  SearchResult,\n  SearchPlatform,\n  QueueStore,\n  PlaylistInfo,\n} from '../types';\nimport { Node } from './Node';\nimport { Player } from './Player';\nimport { Track } from './Track';\nimport { Validator } from '../utils/Validator';\n\ninterface PlayHistory {\n  queue: string[];\n  set: Set<string>;\n}\n\nexport class LavalinkManager extends EventEmitter {\n  public nodes: Map<string, Node> = new Map();\n  public players: Map<string, Player> = new Map();\n  \n  private options: LavalinkManagerOptions;\n  private validator: Validator;\n  private _clientId?: string;\n  private initiated = false;\n  private playedTracksHistory: Map<string, PlayHistory> = new Map();\n\n  get clientId(): string | undefined {\n    return this._clientId;\n  }\n\n  constructor(options: LavalinkManagerOptions) {\n    super();\n    \n    if (!options.nodes || options.nodes.length === 0) {\n      throw new Error('At least one node is required');\n    }\n    \n    if (!options.sendPayload || typeof options.sendPayload !== 'function') {\n      throw new Error('sendPayload callback is required and must be a function');\n    }\n\n    this.options = options;\n    this.validator = new Validator(options.validationOptions);\n\n    for (const nodeOptions of options.nodes) {\n      const node = new Node(nodeOptions);\n      this.setupNodeListeners(node);\n      this.nodes.set(node.identifier, node);\n    }\n  }\n\n  private setupNodeListeners(node: Node): void {\n    node.on('connect', () => {\n      this.emit('nodeConnect', node);\n    });\n\n    node.on('ready', () => {\n      this.emit('ready', node);\n    });\n\n    node.on('reconnecting', () => {\n      this.emit('nodeReconnect', node);\n    });\n\n    node.on('disconnect', (reason: string) => {\n      this.emit('nodeDisconnect', node, reason);\n    });\n\n    node.on('error', (error: Error) => {\n      this.emit('nodeError', node, error);\n    });\n\n    node.on('raw', (payload: any) => {\n      this.emit('nodeRaw', node, payload);\n    });\n\n    node.on('event', (payload: any) => {\n      this.handleNodeEvent(node, payload);\n    });\n\n    node.on('playerUpdate', (payload: any) => {\n      const player = this.players.get(payload.guildId);\n      if (player) {\n        player.updateState(payload);\n      }\n    });\n  }\n\n  private handleNodeEvent(_node: Node, payload: any): void {\n    const player = this.players.get(payload.guildId);\n    if (!player) return;\n\n    switch (payload.type) {\n      case 'TrackStartEvent':\n        const startTrack = new Track(payload.track);\n        if (player.queue.current) {\n          player.setLastPlayedTrack(player.queue.current);\n        }\n        this.emit('trackStart', player, startTrack);\n        player.setPlaying(true);\n        break;\n\n      case 'TrackEndEvent':\n        const endTrack = new Track(payload.track);\n        this.emit('trackEnd', player, endTrack, payload.reason);\n        player.setPlaying(false);\n\n        if (payload.reason === 'finished' || payload.reason === 'loadFailed') {\n          this.handleTrackEnd(player, endTrack);\n        }\n        break;\n\n      case 'TrackExceptionEvent':\n        const exceptionTrack = new Track(payload.track);\n        this.emit('trackError', player, exceptionTrack, payload.exception);\n        this.handleTrackEnd(player, exceptionTrack);\n        break;\n\n      case 'TrackStuckEvent':\n        const stuckTrack = new Track(payload.track);\n        this.emit('trackStuck', player, stuckTrack, payload.thresholdMs);\n        this.handleTrackEnd(player, stuckTrack);\n        break;\n\n      case 'WebSocketClosedEvent':\n        this.emit('socketClosed', player, payload.code, payload.reason, payload.byRemote);\n        break;\n    }\n  }\n\n  private async handleTrackEnd(player: Player, finishedTrack: Track): Promise<void> {\n    await player.queue.initialize();\n    \n    if (player.queue.size > 0) {\n      await player.skip();\n    } else if (player.autoPlay === true) {\n      const trackForAutoplay = player.lastPlayedTrack || player.queue.current || finishedTrack;\n      \n      if (!trackForAutoplay) {\n        this.emit('queueEnd', player);\n        return;\n      }\n      \n      try {\n        const relatedTracks = await this.getRelatedTracks(trackForAutoplay);\n        if (relatedTracks.length > 0) {\n          const randomTrack = relatedTracks[Math.floor(Math.random() * relatedTracks.length)];\n          await player.queue.add(randomTrack);\n          await player.skip();\n          this.emit('autoPlayTrack', player, randomTrack);\n        } else {\n          this.emit('queueEnd', player);\n        }\n      } catch (error) {\n        console.error('AutoPlay failed:', error);\n        this.emit('queueEnd', player);\n      }\n    } else {\n      this.emit('queueEnd', player);\n    }\n  }\n\n  private async getRelatedTracks(track: Track): Promise<Track[]> {\n    try {\n      const guildId = track.requester?.guildId || 'default';\n      \n      if (!this.playedTracksHistory.has(guildId)) {\n        this.playedTracksHistory.set(guildId, { queue: [], set: new Set() });\n      }\n      const history = this.playedTracksHistory.get(guildId)!;\n      \n      history.queue.push(track.info.identifier);\n      history.set.add(track.info.identifier);\n      \n      if (history.queue.length > 50) {\n        const removed = history.queue.shift()!;\n        history.set.delete(removed);\n      }\n      \n      const last25Tracks = new Set(history.queue.slice(-25));\n      \n      const trackTitle = track.info.title.toLowerCase();\n      const titleWords = track.info.title.split(' ').filter(w => \n        !['official', 'audio', 'video', 'lyrics', 'lyric', 'hd', '4k', 'mv'].includes(w.toLowerCase())\n      );\n      const cleanTitle = titleWords.slice(0, 4).join(' ');\n      \n      const searchStrategies = [\n        `${track.info.author} popular songs`,\n        `${track.info.author} top hits`,\n        `${cleanTitle} similar songs`,\n        `${track.info.author} latest`,\n        `artists like ${track.info.author}`,\n        `${cleanTitle.split(' ')[0]} ${track.info.author}`,\n      ];\n      \n      const allCandidates: Track[] = [];\n      const seenIdentifiers = new Set<string>();\n      seenIdentifiers.add(track.info.identifier);\n      \n      for (const strategy of searchStrategies) {\n        try {\n          const result = await this.search(strategy, track.requester, 'youtube');\n          \n          if (result.loadType === 'search' && Array.isArray(result.data)) {\n            const tracks = result.data as any as Track[];\n            \n            for (const t of tracks) {\n              const candidateTitle = t.info.title.toLowerCase();\n              const isSameTitle = candidateTitle === trackTitle;\n              const isTooSimilar = candidateTitle.includes(trackTitle.substring(0, 20)) || \n                                   trackTitle.includes(candidateTitle.substring(0, 20));\n              \n              if (\n                !seenIdentifiers.has(t.info.identifier) &&\n                !last25Tracks.has(t.info.identifier) &&\n                !isSameTitle &&\n                !isTooSimilar\n              ) {\n                seenIdentifiers.add(t.info.identifier);\n                allCandidates.push(t);\n              }\n              \n              if (allCandidates.length >= 20) break;\n            }\n          }\n          \n          if (allCandidates.length >= 20) break;\n        } catch (error) {\n          console.warn(`Search strategy \"${strategy}\" failed:`, error);\n          continue;\n        }\n      }\n      \n      if (allCandidates.length === 0) {\n        const fallbackQuery = `${track.info.author} mix`;\n        const fallbackResult = await this.search(fallbackQuery, track.requester, 'youtube');\n        \n        if (fallbackResult.loadType === 'search' && Array.isArray(fallbackResult.data)) {\n          const tracks = fallbackResult.data as any as Track[];\n          const trackTitle = track.info.title.toLowerCase();\n          return tracks.filter((t) => {\n            const candidateTitle = t.info.title.toLowerCase();\n            return !last25Tracks.has(t.info.identifier) &&\n              !seenIdentifiers.has(t.info.identifier) &&\n              candidateTitle !== trackTitle;\n          }).slice(0, 20);\n        }\n      }\n      \n      return allCandidates;\n    } catch (error) {\n      console.error('Failed to get related tracks:', error);\n      return [];\n    }\n  }\n\n  async init(clientId: string): Promise<void> {\n    if (this.initiated) {\n      throw new Error('Manager already initiated');\n    }\n\n    this._clientId = clientId;\n    this.initiated = true;\n\n    const promises = Array.from(this.nodes.values()).map(node => \n      node.connect(clientId).catch(error => {\n        this.emit('nodeError', node, error);\n      })\n    );\n\n    await Promise.allSettled(promises);\n  }\n\n  createPlayer(options: PlayerOptions, queueStore?: QueueStore): Player {\n    if (this.players.has(options.guildId)) {\n      return this.players.get(options.guildId)!;\n    }\n\n    const node = this.getBestNode(options.node);\n    if (!node) {\n      throw new Error('No available nodes');\n    }\n\n    const defaultOptions = {\n      ...this.options.playerOptions,\n      ...options,\n    };\n\n    const player = new Player(defaultOptions, node, this.options.sendPayload, queueStore);\n    this.players.set(options.guildId, player);\n    \n    this.emit('playerCreate', player);\n    \n    return player;\n  }\n\n  getPlayer(guildId: string): Player | undefined {\n    return this.players.get(guildId);\n  }\n\n  async destroyPlayer(guildId: string, reason?: any): Promise<void> {\n    const player = this.players.get(guildId);\n    if (!player) return;\n\n    await player.destroy(reason);\n    this.players.delete(guildId);\n    \n    this.playedTracksHistory.delete(guildId);\n    \n    this.emit('playerDestroy', player, reason);\n  }\n\n  private getBestNode(identifier?: string): Node | null {\n    if (identifier) {\n      const node = this.nodes.get(identifier);\n      if (node?.isConnected) return node;\n    }\n\n    const connectedNodes = Array.from(this.nodes.values())\n      .filter(node => node.isConnected);\n\n    if (connectedNodes.length === 0) return null;\n\n    return connectedNodes.reduce((best, node) => {\n      const bestPlayers = best.stats?.players || 0;\n      const nodePlayers = node.stats?.players || 0;\n      return nodePlayers < bestPlayers ? node : best;\n    });\n  }\n\n  async search(\n    query: string,\n    requester?: any,\n    source?: SearchPlatform\n  ): Promise<SearchResult> {\n    const node = this.getBestNode();\n    if (!node) {\n      throw new Error('No available nodes');\n    }\n\n    const searchSource = source || this.options.defaultSearchPlatform || 'youtube';\n    let searchQuery = query;\n\n    if (!query.startsWith('http')) {\n      const sourceMap: Record<string, string> = {\n        youtube: 'ytsearch',\n        youtubemusic: 'ytmsearch',\n        soundcloud: 'scsearch',\n        spotify: 'spsearch',\n        deezer: 'dzsearch',\n        applemusic: 'amsearch',\n        yandex: 'ymsearch',\n      };\n      searchQuery = `${sourceMap[searchSource]}:${query}`;\n    } else {\n      const validation = this.validator.validateUrl(query);\n      if (!validation.valid) {\n        throw new Error(`URL validation failed: ${validation.reason}`);\n      }\n    }\n\n    const result = await node.request<any>(\n      `/loadtracks?identifier=${encodeURIComponent(searchQuery)}`\n    );\n\n    let tracks: Track[] = [];\n    let playlistInfo: PlaylistInfo | undefined;\n\n    if (result.loadType === 'search' || result.loadType === 'track') {\n      tracks = Array.isArray(result.data) ? result.data : [];\n    } else if (result.loadType === 'playlist') {\n      if (result.data && typeof result.data === 'object' && 'tracks' in result.data) {\n        tracks = result.data.tracks || [];\n        playlistInfo = result.data.info;\n      }\n    }\n\n    if (tracks.length > 0) {\n      const trackInstances = tracks.map(track => new Track(track, requester));\n      \n      if (result.loadType === 'playlist' && playlistInfo) {\n        const playlistValidation = this.validator.validatePlaylistSize(trackInstances.length);\n        if (!playlistValidation.valid) {\n          throw new Error(playlistValidation.reason);\n        }\n      }\n      \n      for (const track of trackInstances) {\n        const lengthValidation = this.validator.validateTrackLength(track.duration);\n        if (!lengthValidation.valid) {\n          console.warn(`Track ${track.title} validation warning: ${lengthValidation.reason}`);\n        }\n      }\n      \n      tracks = trackInstances as any;\n    }\n\n    return {\n      loadType: result.loadType,\n      data: result.loadType === 'playlist' && playlistInfo\n        ? { info: playlistInfo, pluginInfo: {}, tracks }\n        : tracks,\n    } as SearchResult;\n  }\n\n  updateVoiceState(data: any): void {\n    const player = this.players.get(data.guild_id);\n    if (!player) return;\n\n    if (data.user_id && data.user_id !== this._clientId) {\n      return;\n    }\n\n    if (data.channel_id === null) {\n      this.emit('playerDisconnect', player, player.voiceChannelId);\n      return;\n    }\n\n    if (player.voiceChannelId !== data.channel_id) {\n      this.emit('playerMove', player, player.voiceChannelId, data.channel_id);\n      player.voiceChannelId = data.channel_id;\n    }\n\n    if (data.session_id) {\n      player.setVoiceState({ sessionId: data.session_id });\n    }\n  }\n\n  updateVoiceServer(data: any): void {\n    const player = this.players.get(data.guild_id);\n    if (!player) return;\n\n    player.setVoiceState({\n      event: {\n        token: data.token,\n        guild_id: data.guild_id,\n        endpoint: data.endpoint,\n      },\n    });\n  }\n}\n","size_bytes":13573},"src/index.ts":{"content":"export { LavalinkManager } from './structures/LavalinkManager';\nexport { Player } from './structures/Player';\nexport { Node } from './structures/Node';\nexport { Queue } from './structures/Queue';\nexport { Track, UnresolvedTrackImpl as UnresolvedTrack } from './structures/Track';\nexport { FilterManager } from './filters/FilterManager';\nexport { FILTER_PRESETS, type PresetName } from './filters/presets';\nexport { Validator } from './utils/Validator';\nexport { AudioNormalizer } from './utils/AudioNormalizer';\nexport { MusicCardGenerator, type MusicCardOptions, type MusicCardTheme } from './utils/MusicCardGenerator';\nexport { MemoryStore } from './stores/MemoryStore';\nexport { RedisStoreAdapter, type RedisClient } from './stores/RedisStoreAdapter';\nexport { DestroyReasons } from './types/lavalink';\n\nexport type {\n  NodeOptions,\n  LavalinkManagerOptions,\n  ValidationOptions,\n  DefaultPlayerOptions,\n  SearchPlatform,\n  Track as TrackData,\n  TrackInfo,\n  UnresolvedTrack as UnresolvedTrackData,\n  SearchResult,\n  PlaylistInfo,\n  ExceptionInfo,\n  VoiceState,\n  VoiceServerUpdate,\n  PlayerUpdateInfo,\n  PlayerState,\n  LavalinkPlayerVoice,\n  LavalinkPlayer,\n  FilterData,\n  EqualizerBand,\n  KaraokeFilter,\n  TimescaleFilter,\n  TremoloFilter,\n  VibratoFilter,\n  RotationFilter,\n  DistortionFilter,\n  ChannelMixFilter,\n  LowPassFilter,\n  NodeStats,\n  LavalinkNodeInfo,\n  PluginInfo,\n} from './types/lavalink';\n\nexport type {\n  ManagerEvents,\n  TrackEndReason,\n  TrackException,\n  NodeEvents,\n  WebSocketClosedEvent,\n  TrackStartEvent,\n  TrackEndEvent,\n  TrackExceptionEvent,\n  TrackStuckEvent,\n} from './types/events';\n\nexport type {\n  QueueStore,\n  QueueData,\n  PlayerOptions,\n  ConnectOptions,\n  PlayOptions,\n  SearchQuery,\n} from './types/index';\n","size_bytes":1752},"testbot/README.md":{"content":"# ðŸ¤– Aliana-Client Test Bot\n\nA fully functional Discord music bot built to test the `aliana-client` package.\n\n## Features\n\nThis test bot demonstrates all the features of `aliana-client`:\n\n- âœ… **Music Playback** - Play songs from YouTube and other sources\n- âœ… **Queue Management** - Add, skip, and manage your music queue\n- âœ… **Smart Autoplay** - Intelligent track recommendations (plays different, similar songs)\n- âœ… **Audio Filters** - 10+ presets including bassboost, nightcore, vaporwave, 8D, karaoke, and more\n- âœ… **Advanced Filters** - Echo, reverb, audio output control (mono/stereo/left/right)\n- âœ… **Music Cards** - Generate beautiful visual music cards with the built-in generator\n- âœ… **Player Controls** - Pause, resume, volume control\n- âœ… **Event Handling** - Proper event listeners for all player events\n- âœ… **Voice State Management** - Automatic cleanup and reconnection\n\n## Prerequisites\n\nBefore running the test bot, you need:\n\n1. **Node.js 18+** installed\n2. **A Discord Bot Token**\n   - Go to [Discord Developer Portal](https://discord.com/developers/applications)\n   - Create a new application\n   - Go to the \"Bot\" section and create a bot\n   - Copy the token\n   - Enable \"Message Content Intent\" in the bot settings\n   \n3. **Lavalink Server Running**\n   - Download Lavalink v4: https://github.com/lavalink-devs/Lavalink/releases\n   - Create `application.yml`:\n     ```yaml\n     server:\n       port: 2333\n       address: 0.0.0.0\n     lavalink:\n       server:\n         password: \"youshallnotpass\"\n         sources:\n           youtube: true\n           bandcamp: true\n           soundcloud: true\n           twitch: true\n           vimeo: true\n           http: true\n           local: false\n         bufferDurationMs: 400\n         frameBufferDurationMs: 5000\n         youtubePlaylistLoadLimit: 6\n         playerUpdateInterval: 5\n         youtubeSearchEnabled: true\n         soundcloudSearchEnabled: true\n         gc-warnings: true\n     ```\n   - Run: `java -jar Lavalink.jar`\n\n## Setup Instructions\n\n### 1. Install Dependencies\n\n```bash\ncd testbot\nnpm install\n```\n\n### 2. Configure Lavalink Connection\n\nEdit `config.json` if your Lavalink server is not on localhost:\n\n```json\n{\n  \"prefix\": \"!\",\n  \"lavalink\": {\n    \"nodes\": [\n      {\n        \"id\": \"main\",\n        \"host\": \"localhost\",\n        \"port\": 2333,\n        \"password\": \"youshallnotpass\"\n      }\n    ]\n  }\n}\n```\n\n### 3. Set Bot Token\n\nThe bot token will be requested when you run the bot (managed by Replit Secrets).\n\n### 4. Invite Bot to Server\n\nUse this URL (replace `YOUR_CLIENT_ID` with your bot's client ID from Discord Developer Portal):\n\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=36703232&scope=bot\n```\n\nRequired permissions:\n- View Channels\n- Send Messages\n- Connect to Voice\n- Speak\n\n### 5. Run the Bot\n\n```bash\nnpm start\n```\n\n## Commands\n\n### Music Controls\n| Command | Description | Example |\n|---------|-------------|---------|\n| `!play <query>` | Play a song or add to queue | `!play never gonna give you up` |\n| `!pause` | Pause playback | `!pause` |\n| `!resume` | Resume playback | `!resume` |\n| `!skip` | Skip current track | `!skip` |\n| `!stop` | Stop and clear queue | `!stop` |\n| `!volume <0-100>` | Set volume | `!volume 50` |\n| `!autoplay` | Toggle smart autoplay | `!autoplay` |\n\n### Queue Management\n| Command | Description | Example |\n|---------|-------------|---------|\n| `!queue` | Show current queue | `!queue` |\n| `!nowplaying` or `!np` | Show current track info | `!np` |\n| `!card` or `!musiccard` | Generate music card image | `!card` |\n\n### Filter Presets\n| Command | Description | Example |\n|---------|-------------|---------|\n| `!filter <preset>` | Apply audio filter preset | `!filter bassboost` |\n\nAvailable presets:\n- `bassboost` - Enhanced bass\n- `nightcore` - Higher pitch and tempo\n- `vaporwave` - Slowed and reverb\n- `8d` - 8D audio effect\n- `karaoke` - Remove vocals\n- `soft` - Soft sound\n- `pop` - Pop music EQ\n- `electronic` - Electronic music EQ\n- `rock` - Rock music EQ\n- `classical` - Classical music EQ\n- `clear` - Remove all filters\n\n### Advanced Filters\n| Command | Description | Example |\n|---------|-------------|---------|\n| `!echo [delay] [decay]` | Apply echo effect | `!echo 1.5 0.6` |\n| `!reverb` | Apply reverb effect | `!reverb` |\n| `!output <type>` | Set audio output | `!output mono` |\n\nAudio output types: `mono`, `stereo`, `left`, `right`\n\n### Other\n| Command | Description | Example |\n|---------|-------------|---------|\n| `!help` | Show help message | `!help` |\n\n## Testing Checklist\n\nUse this bot to verify `aliana-client` is working:\n\n- [ ] Bot connects to Lavalink successfully\n- [ ] `!play` searches and plays music\n- [ ] Track starts event fires correctly\n- [ ] Queue management works (add, skip, show)\n- [ ] Pause/resume functions properly\n- [ ] Volume control adjusts audio\n- [ ] Filters apply and affect audio\n- [ ] Track end transitions to next song\n- [ ] Queue end event fires when queue finishes\n- [ ] Player cleanup on disconnect\n- [ ] Error handling for invalid songs\n- [ ] Multiple guilds work independently\n\n## Troubleshooting\n\n### Bot doesn't respond to commands\n- Check if bot is online in Discord\n- Verify \"Message Content Intent\" is enabled\n- Check console for errors\n\n### No audio plays\n- Ensure Lavalink server is running\n- Verify Lavalink configuration matches `config.json`\n- Check if bot has permission to join voice channel\n- Verify Java 17+ is installed for Lavalink\n\n### Lavalink connection fails\n- Check if port 2333 is accessible\n- Verify password matches in `application.yml` and `config.json`\n- Check Lavalink console for errors\n\n### Filters don't work\n- Ensure you're using valid preset names\n- Check if track is playing before applying filter\n- Verify Lavalink supports filter plugins\n\n## Project Structure\n\n```\ntestbot/\nâ”œâ”€â”€ src/\nâ”‚   â””â”€â”€ index.ts          # Main bot code\nâ”œâ”€â”€ config/\nâ”œâ”€â”€ config.json           # Lavalink configuration\nâ”œâ”€â”€ package.json          # Dependencies\nâ”œâ”€â”€ tsconfig.json         # TypeScript config\nâ””â”€â”€ README.md            # This file\n```\n\n## What This Tests\n\nThis bot tests the following `aliana-client` components:\n\n1. **LavalinkManager** - Initialization, node management, search\n2. **Player** - Creation, playback, voice connection\n3. **Queue** - Adding tracks, retrieving current/next\n4. **Track** - Loading from search results\n5. **Filters** - Applying and clearing filter presets\n6. **Events** - All manager and player events\n7. **Voice State** - Discord voice state updates\n\n## Next Steps\n\nAfter verifying the test bot works:\n\n1. Review the source code to see how to use `aliana-client`\n2. Check the main [TESTING_GUIDE.md](../TESTING_GUIDE.md) for more test scenarios\n3. Read the [API_REFERENCE.md](../API_REFERENCE.md) for detailed API docs\n4. Build your own bot with `aliana-client`!\n\n## Support\n\nIf you encounter issues:\n1. Check Lavalink server logs\n2. Check bot console output\n3. Verify all configurations are correct\n4. Review the main package documentation\n\n---\n\nBuilt with â¤ï¸ using `aliana-client`\n","size_bytes":7112},"testbot/src/index.ts":{"content":"import { Client, GatewayIntentBits, Message, VoiceState, TextChannel, AttachmentBuilder } from 'discord.js';\nimport { LavalinkManager, Player, Track, DestroyReasons, Node, MusicCardGenerator } from 'aliana-client';\nimport type { SearchResult } from 'aliana-client';\nimport config from '../config.json';\n\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.GuildVoiceStates,\n    GatewayIntentBits.MessageContent,\n  ],\n});\n\nconst manager = new LavalinkManager({\n  nodes: config.lavalink.nodes,\n  sendPayload: (guildId: string, payload: any) => {\n    const guild = client.guilds.cache.get(guildId);\n    if (guild) guild.shard.send(payload);\n  },\n});\n\nclient.on('ready', () => {\n  console.log(`âœ… Bot logged in as ${client.user?.tag}`);\n  console.log(`ðŸŽµ Connecting to Lavalink nodes...`);\n  manager.init(client.user!.id);\n  console.log(`ðŸ“ Prefix: ${config.prefix}`);\n  console.log(`ðŸ’¡ Try: ${config.prefix}play <song name>`);\n});\n\nclient.on('raw', (packet: any) => {\n  if (packet.t === 'VOICE_STATE_UPDATE') {\n    console.log('ðŸ“¡ Received VOICE_STATE_UPDATE:', packet.d.guild_id);\n    manager.updateVoiceState(packet.d);\n  } else if (packet.t === 'VOICE_SERVER_UPDATE') {\n    console.log('ðŸ“¡ Received VOICE_SERVER_UPDATE:', packet.d.guild_id);\n    manager.updateVoiceServer(packet.d);\n  }\n});\n\nclient.on('voiceStateUpdate', (oldState: VoiceState, newState: VoiceState) => {\n  const player = manager.players.get(newState.guild.id);\n  if (!player) return;\n\n  if (oldState.channelId && !newState.channelId && newState.member?.id === client.user?.id) {\n    player.destroy(DestroyReasons.Disconnected);\n    console.log(`ðŸ”Œ Disconnected from voice in ${newState.guild.name}`);\n  }\n});\n\nmanager.on('nodeConnect', (node: Node) => {\n  console.log(`âœ… Node \"${node.options.identifier}\" connected!`);\n});\n\nmanager.on('nodeRaw', (node: Node, payload: any) => {\n  console.log(`ðŸ“¦ Raw from Lavalink:`, JSON.stringify(payload));\n});\n\nmanager.on('nodeError', (node: Node, error: Error) => {\n  console.error(`âŒ Node \"${node.options.identifier}\" error:`, error.message);\n});\n\nmanager.on('trackError', (player: Player, track: Track, error: any) => {\n  console.error(`âŒ Track error: ${track.info.title}`, error);\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel && 'send' in channel) {\n    (channel as TextChannel).send(`âŒ Error playing: **${track.info.title}** - ${error.message || 'Unknown error'}`);\n  }\n});\n\nmanager.on('trackStart', (player: Player, track: Track) => {\n  console.log(`ðŸŽµ Track started: ${track.info.title}`);\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel && 'send' in channel) {\n    (channel as TextChannel).send(`ðŸŽµ Now playing: **${track.info.title}** by **${track.info.author}**`);\n  }\n});\n\nmanager.on('trackEnd', (player: Player, track: Track) => {\n  console.log(`âœ… Track ended: ${track.info.title} | AutoPlay: ${player.autoPlay}`);\n});\n\nmanager.on('autoPlayTrack', (player: Player, track: Track) => {\n  console.log(`ðŸŽµ AutoPlay: ${track.info.title}`);\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel && 'send' in channel) {\n    (channel as TextChannel).send(`ðŸŽµ **AutoPlay**: Now playing **${track.info.title}** by **${track.info.author}**`);\n  }\n});\n\nmanager.on('queueEnd', (player: Player) => {\n  const channel = client.channels.cache.get(player.textChannelId!);\n  if (channel && 'send' in channel) {\n    if (!player.autoPlay) {\n      (channel as TextChannel).send('ðŸ“­ Queue finished! Add more songs or I\\'ll leave in 5 minutes. (Use !autoplay to enable continuous playback)');\n    }\n  }\n  \n  if (!player.autoPlay) {\n    setTimeout(() => {\n      if (player.queue.tracks.length === 0 && !player.playing) {\n        player.destroy(DestroyReasons.QueueEmpty);\n        if (channel && 'send' in channel) {\n          (channel as TextChannel).send('ðŸ‘‹ Left due to inactivity.');\n        }\n      }\n    }, 5 * 60 * 1000);\n  }\n});\n\nmanager.on('playerDestroy', (player: Player, reason: string) => {\n  console.log(`ðŸ—‘ï¸ Player destroyed in guild ${player.guildId}. Reason: ${reason}`);\n});\n\nclient.on('messageCreate', async (message: Message) => {\n  if (message.author.bot || !message.content.startsWith(config.prefix)) return;\n\n  const args = message.content.slice(config.prefix.length).trim().split(/ +/);\n  const command = args.shift()?.toLowerCase();\n\n  if (!command) return;\n\n  try {\n    switch (command) {\n      case 'play':\n        await handlePlay(message, args);\n        break;\n      case 'skip':\n        await handleSkip(message);\n        break;\n      case 'stop':\n        await handleStop(message);\n        break;\n      case 'pause':\n        await handlePause(message);\n        break;\n      case 'resume':\n        await handleResume(message);\n        break;\n      case 'queue':\n        await handleQueue(message);\n        break;\n      case 'nowplaying':\n      case 'np':\n        await handleNowPlaying(message);\n        break;\n      case 'volume':\n        await handleVolume(message, args);\n        break;\n      case 'filter':\n        await handleFilter(message, args);\n        break;\n      case 'echo':\n        await handleEcho(message, args);\n        break;\n      case 'reverb':\n        await handleReverb(message);\n        break;\n      case 'audiooutput':\n      case 'output':\n        await handleAudioOutput(message, args);\n        break;\n      case 'musiccard':\n      case 'card':\n        await handleMusicCard(message, args);\n        break;\n      case 'autoplay':\n        await handleAutoPlay(message);\n        break;\n      case 'help':\n        await handleHelp(message);\n        break;\n      default:\n        break;\n    }\n  } catch (error: any) {\n    console.error('Command error:', error);\n    message.reply(`âŒ Error: ${error.message}`);\n  }\n});\n\nasync function handlePlay(message: Message, args: string[]) {\n  const voiceChannel = message.member?.voice.channel;\n  if (!voiceChannel) {\n    return message.reply('âŒ You need to be in a voice channel!');\n  }\n\n  const query = args.join(' ');\n  if (!query) {\n    return message.reply('âŒ Please provide a song name or URL!');\n  }\n\n  let player = manager.players.get(message.guild!.id);\n  \n  if (!player) {\n    player = manager.createPlayer({\n      guildId: message.guild!.id,\n      voiceChannelId: voiceChannel.id,\n      textChannelId: message.channel.id,\n      selfDeaf: true,\n    });\n    await player.connect();\n  }\n\n  const result = await manager.search(query, message.author.id, 'youtube');\n\n  if (result.loadType === 'error' || result.loadType === 'empty') {\n    return message.reply('âŒ No results found!');\n  }\n\n  const tracks = Array.isArray(result.data) \n    ? result.data \n    : result.data && 'tracks' in result.data \n    ? result.data.tracks \n    : [];\n\n  if (tracks.length === 0) {\n    return message.reply('âŒ No tracks found in search results!');\n  }\n\n  for (const track of tracks) {\n    await player.queue.add(track as any);\n  }\n\n  if (result.loadType === 'playlist' && !Array.isArray(result.data) && result.data.info) {\n    message.reply(`ðŸ“‹ Added **${tracks.length}** tracks from **${result.data.info.name}** to queue!`);\n  } else {\n    message.reply(`âœ… Added **${tracks[0].info.title}** to queue!`);\n  }\n\n  console.log(`Player state - playing: ${player.playing}, paused: ${player.paused}, connected: ${player.connected}`);\n  console.log(`Queue state - current: ${player.queue.current?.info.title || 'none'}, size: ${player.queue.size}`);\n  \n  if (!player.playing && !player.paused) {\n    console.log('Attempting to start playback...');\n    try {\n      await player.play();\n      console.log('Play command sent successfully');\n    } catch (error: any) {\n      console.error('Error during play:', error.message);\n      message.reply(`âŒ Playback error: ${error.message}`);\n    }\n  }\n}\n\nasync function handleSkip(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  player.skip();\n  message.reply('â­ï¸ Skipped!');\n}\n\nasync function handleStop(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  player.destroy(DestroyReasons.Cleanup);\n  message.reply('â¹ï¸ Stopped and cleared the queue!');\n}\n\nasync function handlePause(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  player.pause(true);\n  message.reply('â¸ï¸ Paused!');\n}\n\nasync function handleResume(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  player.pause(false);\n  message.reply('â–¶ï¸ Resumed!');\n}\n\nasync function handleQueue(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  const current = player.queue.current;\n  const upcoming = player.queue.tracks.slice(0, 10);\n\n  let queueText = 'ðŸ“‹ **Current Queue**\\n\\n';\n  \n  if (current) {\n    queueText += `ðŸŽµ **Now Playing:**\\n${current.info.title} - ${current.info.author}\\n\\n`;\n  }\n\n  if (upcoming.length > 0) {\n    queueText += '**Up Next:**\\n';\n    upcoming.forEach((track: Track, index: number) => {\n      queueText += `${index + 1}. ${track.info.title} - ${track.info.author}\\n`;\n    });\n    \n    if (player.queue.tracks.length > 10) {\n      queueText += `\\n...and ${player.queue.tracks.length - 10} more tracks`;\n    }\n  } else {\n    queueText += 'No upcoming tracks.';\n  }\n\n  message.reply(queueText);\n}\n\nasync function handleNowPlaying(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  const current = player.queue.current;\n  if (!current) return message.reply('âŒ Nothing is playing!');\n\n  const position = formatTime(player.position);\n  const duration = formatTime(current.info.length);\n\n  message.reply(\n    `ðŸŽµ **Now Playing:**\\n` +\n    `**${current.info.title}**\\n` +\n    `By: ${current.info.author}\\n` +\n    `Progress: ${position} / ${duration}\\n` +\n    `Volume: ${player.volume}%`\n  );\n}\n\nasync function handleVolume(message: Message, args: string[]) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  const volume = parseInt(args[0]);\n  if (isNaN(volume) || volume < 0 || volume > 100) {\n    return message.reply('âŒ Volume must be between 0 and 100!');\n  }\n\n  player.setVolume(volume);\n  message.reply(`ðŸ”Š Volume set to ${volume}%`);\n}\n\nasync function handleFilter(message: Message, args: string[]) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  const filterName = args[0]?.toLowerCase();\n  \n  if (!filterName) {\n    return message.reply(\n      'ðŸŽ›ï¸ **Available Filter Presets:**\\n' +\n      '`bassboost`, `nightcore`, `vaporwave`, `8d`, `karaoke`, `soft`, `pop`, `electronic`, `rock`, `classical`, `clear`\\n\\n' +\n      '**Additional Filters:**\\n' +\n      `\\`${config.prefix}echo [delay] [decay]\\` - Echo effect\\n` +\n      `\\`${config.prefix}reverb\\` - Reverb effect\\n` +\n      `\\`${config.prefix}output <mono|stereo|left|right>\\` - Audio output\\n\\n` +\n      `Usage: ${config.prefix}filter <preset>`\n    );\n  }\n\n  if (filterName === 'clear') {\n    await player.filters.clearFilters();\n    return message.reply('ðŸ”„ All filters cleared!');\n  }\n\n  const filterMap: Record<string, string> = {\n    'bassboost': 'bassBoost',\n    'nightcore': 'nightcore',\n    'vaporwave': 'vaporwave',\n    '8d': 'eightD',\n    'karaoke': 'karaoke',\n    'soft': 'soft',\n    'pop': 'pop',\n    'electronic': 'electronic',\n    'rock': 'rock',\n    'classical': 'classical',\n  };\n\n  if (!filterMap[filterName]) {\n    return message.reply('âŒ Invalid filter! Check available filters with `!filter`');\n  }\n\n  await player.filters.setPreset(filterMap[filterName] as any);\n  message.reply(`ðŸŽ›ï¸ Applied **${filterName}** filter!`);\n}\n\nasync function handleEcho(message: Message, args: string[]) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  const delay = parseFloat(args[0]) || 1.0;\n  const decay = parseFloat(args[1]) || 0.5;\n\n  if (delay === 0 && decay === 0) {\n    await player.filters.setEcho();\n    return message.reply('âŒ Echo effect disabled!');\n  }\n\n  await player.filters.setEcho(delay, decay);\n  message.reply(`ðŸ”Š Echo effect applied! (Delay: ${delay}s, Decay: ${decay})`);\n}\n\nasync function handleReverb(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  await player.filters.setReverb();\n  message.reply('ðŸŽµ Reverb effect applied!');\n}\n\nasync function handleAudioOutput(message: Message, args: string[]) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  const type = args[0]?.toLowerCase() as 'mono' | 'stereo' | 'left' | 'right';\n  \n  if (!type || !['mono', 'stereo', 'left', 'right'].includes(type)) {\n    return message.reply(\n      'ðŸ”Š **Audio Output Options:**\\n' +\n      '`mono` - Mono output\\n' +\n      '`stereo` - Stereo output (default)\\n' +\n      '`left` - Left channel only\\n' +\n      '`right` - Right channel only\\n\\n' +\n      `Usage: ${config.prefix}output <type>`\n    );\n  }\n\n  await player.filters.setAudioOutput(type);\n  message.reply(`ðŸ”Š Audio output set to **${type}**!`);\n}\n\nasync function handleMusicCard(message: Message, args: string[]) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing!');\n\n  const current = player.queue.current;\n  if (!current) return message.reply('âŒ No track is currently playing!');\n\n  try {\n    const theme = (args[0] as 'classic' | 'classicPro' | 'dynamic') || 'dynamic';\n    const validThemes = ['classic', 'classicPro', 'dynamic'];\n    \n    if (args[0] && !validThemes.includes(args[0])) {\n      return message.reply(\n        `âŒ Invalid theme! Available themes:\\n` +\n        `â€¢ \\`classic\\` - Simple classic design\\n` +\n        `â€¢ \\`classicPro\\` - Enhanced classic with more details\\n` +\n        `â€¢ \\`dynamic\\` - Modern animated design (default)\\n\\n` +\n        `Usage: ${config.prefix}card [theme]`\n      );\n    }\n\n    const statusMsg = await message.reply('ðŸŽ¨ Generating music card...');\n    \n    const card = await MusicCardGenerator.generateCardWithProgress(\n      current,\n      player.position,\n      {\n        backgroundColor: theme === 'dynamic' ? '#070707' : '#1a1a1a',\n        progressColor: '#1DB954',\n        progressBarColor: theme === 'dynamic' ? '#2c2f33' : '#404040',\n        nameColor: '#ffffff',\n        authorColor: '#99aab5',\n        timeColor: '#1DB954',\n      },\n      theme\n    );\n\n    const attachment = new AttachmentBuilder(card, { name: `musicard-${theme}.png` });\n    await statusMsg.edit({\n      content: `ðŸŽ¨ **Music Card Generated!**\\n` +\n        `ðŸ“€ **${current.info.title}**\\n` +\n        `ðŸŽ¤ ${current.info.author}\\n` +\n        `ðŸŽ­ Theme: **${theme}**`,\n      files: [attachment],\n    });\n  } catch (error: any) {\n    console.error('Music card generation error:', error);\n    message.reply(`âŒ Failed to generate music card: ${error.message}`);\n  }\n}\n\nasync function handleAutoPlay(message: Message) {\n  const player = manager.players.get(message.guild!.id);\n  if (!player) return message.reply('âŒ Nothing is playing! Use !play first.');\n\n  if (!message.member?.voice.channel) {\n    return message.reply('âŒ You need to be in the voice channel!');\n  }\n\n  player.setAutoPlay(!player.autoPlay);\n  \n  if (player.autoPlay) {\n    message.reply('âœ… **AutoPlay enabled!** ðŸŽµ\\nI will automatically play related YouTube tracks when the queue ends, just like Spotify!');\n  } else {\n    message.reply('âŒ **AutoPlay disabled.**\\nMusic will stop when the queue ends.');\n  }\n}\n\nasync function handleHelp(message: Message) {\n  const helpText = `\nðŸŽµ **Aliana-Client Test Bot Commands**\n\n**Music Controls:**\n\\`${config.prefix}play <song>\\` - Play a song or add to queue\n\\`${config.prefix}pause\\` - Pause playback\n\\`${config.prefix}resume\\` - Resume playback\n\\`${config.prefix}skip\\` - Skip current track\n\\`${config.prefix}stop\\` - Stop and clear queue\n\\`${config.prefix}volume <0-100>\\` - Set volume\n\\`${config.prefix}autoplay\\` - Toggle autoplay (plays similar songs)\n\n**Queue:**\n\\`${config.prefix}queue\\` - Show current queue\n\\`${config.prefix}nowplaying\\` or \\`${config.prefix}np\\` - Show current track\n\\`${config.prefix}card [theme]\\` - Generate music card (themes: classic, classicPro, dynamic)\n\n**Filter Presets:**\n\\`${config.prefix}filter <preset>\\` - Apply filter preset\nPresets: bassboost, nightcore, vaporwave, 8d, karaoke, soft, pop, electronic, rock, classical, clear\n\n**Advanced Filters:**\n\\`${config.prefix}echo [delay] [decay]\\` - Echo effect\n\\`${config.prefix}reverb\\` - Reverb effect\n\\`${config.prefix}output <type>\\` - Audio output (mono/stereo/left/right)\n\n**Other:**\n\\`${config.prefix}help\\` - Show this message\n\n**âœ¨ New Features:**\nâ€¢ Smart autoplay with varied recommendations (tracks last 50 plays, avoids last 25)\nâ€¢ Echo & reverb filters (requires Lavalink plugins)\nâ€¢ High-pass, low-pass & normalization filters (requires LavaDSPX plugin)\nâ€¢ Audio output control (mono/stereo/left/right channel mixing)\nâ€¢ Built-in music card generator with 3 themes and real-time progress\n  `;\n  \n  message.reply(helpText);\n}\n\nfunction formatTime(ms: number): string {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n}\n\nconst token = process.env.DISCORD_BOT_TOKEN;\n\nif (!token) {\n  console.error('âŒ DISCORD_BOT_TOKEN environment variable is not set!');\n  console.log('Please set your Discord bot token in the Secrets.');\n  process.exit(1);\n}\n\nclient.login(token).catch(error => {\n  console.error('âŒ Failed to login:', error.message);\n  process.exit(1);\n});\n","size_bytes":19335},"TESTING_GUIDE.md":{"content":"# ðŸ§ª Testing Guide for Aliana-Client\n\nThis guide will help you verify that your `aliana-client` package is working correctly.\n\n## Prerequisites\n\nBefore testing, ensure you have:\n- âœ… Node.js 18.0.0 or higher\n- âœ… A Discord bot token\n- âœ… A Lavalink server running (v4.x)\n\n## Quick Test Checklist\n\n### 1. âœ… Package Build Test\n```bash\nnpm run build\n```\n**Expected Result**: Package builds without errors and generates files in `dist/` folder.\n\n### 2. âœ… Type Checking Test\n```bash\nnpm run type-check\n```\n**Expected Result**: No TypeScript errors.\n\n### 3. âœ… Linting Test\n```bash\nnpm run lint\n```\n**Expected Result**: No ESLint errors.\n\n### 4. âœ… Integration Test (Using Test Bot)\nThe `testbot/` folder contains a fully functional Discord music bot that uses your package.\n\n## Testing with the Test Bot\n\n### Setup Instructions\n\n1. **Navigate to the test bot folder:**\n```bash\ncd testbot\n```\n\n2. **Install dependencies:**\n```bash\nnpm install\n```\n\n3. **Configure your bot:**\n   - Set up your Discord bot token (the bot will prompt you)\n   - Configure Lavalink connection in `testbot/config.json`\n\n4. **Start your Lavalink server:**\n   - Download Lavalink v4 from https://github.com/lavalink-devs/Lavalink/releases\n   - Run it with: `java -jar Lavalink.jar`\n\n5. **Run the test bot:**\n```bash\nnpm start\n```\n\n### Test Bot Features to Verify\n\nThe test bot includes these commands to test your package:\n\n| Command | Tests | Expected Behavior |\n|---------|-------|-------------------|\n| `!play <song>` | Track loading & playback | Bot joins voice, plays music |\n| `!skip` | Queue management | Skips to next track |\n| `!queue` | Queue display | Shows current queue |\n| `!pause` | Player controls | Pauses playback |\n| `!resume` | Player controls | Resumes playback |\n| `!stop` | Player cleanup | Stops & clears queue |\n| `!volume <1-100>` | Volume control | Adjusts volume |\n| `!filter <preset>` | Filter system | Applies audio filters |\n| `!nowplaying` | Track info | Shows current track |\n\n### Filter Presets to Test\n\nTest the filter system with these presets:\n- `bassboost` - Enhanced bass\n- `nightcore` - Higher pitch & speed\n- `vaporwave` - Slowed & reverb\n- `8d` - 8D audio effect\n- `clear` - Remove all filters\n\n## Manual Testing Scenarios\n\n### Scenario 1: Basic Playback\n1. Join a voice channel\n2. Use `!play never gonna give you up`\n3. Verify: Bot joins, searches, and plays the track\n4. Use `!nowplaying` to check track info\n5. Use `!stop` to cleanup\n\n### Scenario 2: Queue Management\n1. Queue multiple songs: `!play song1`, `!play song2`, `!play song3`\n2. Use `!queue` to verify all tracks are queued\n3. Use `!skip` to verify it moves to next track\n4. Verify autoplay continues to next track\n\n### Scenario 3: Filters & Audio\n1. Play a song\n2. Apply filter: `!filter bassboost`\n3. Verify audio changes\n4. Clear filter: `!filter clear`\n5. Verify audio returns to normal\n\n### Scenario 4: Error Handling\n1. Try `!play invalidSongThatDoesntExist123456`\n2. Verify: Bot handles search errors gracefully\n3. Try disconnecting bot manually\n4. Verify: Player cleanup happens properly\n\n### Scenario 5: Reconnection\n1. Play a song\n2. Disconnect from voice channel\n3. Rejoin and play again\n4. Verify: New player is created properly\n\n## Checking Package Functionality\n\n### Core Components to Verify\n\n#### âœ… LavalinkManager\n- Node connection established\n- Event handlers working\n- Proper initialization\n\n#### âœ… Player\n- Creates and manages players per guild\n- Handles voice state updates\n- Proper playback control\n\n#### âœ… Queue\n- Adds tracks correctly\n- Returns current track\n- Manages queue order\n\n#### âœ… Track\n- Resolves from search queries\n- Contains correct metadata\n- Plays successfully\n\n#### âœ… Filters\n- Applies filter presets\n- Clears filters\n- Audio effects work correctly\n\n#### âœ… Node\n- WebSocket connection stable\n- Sends/receives Lavalink messages\n- Handles reconnection\n\n## Troubleshooting\n\n### Package Not Working?\n\n1. **Check build output:**\n```bash\nls -la dist/\n```\nShould contain: `index.js`, `index.mjs`, `index.d.ts`, `index.d.mts`\n\n2. **Verify package.json exports:**\n```bash\ncat package.json | grep -A 10 exports\n```\n\n3. **Test import:**\n```javascript\n// Create test.js\nconst { LavalinkManager } = require('./dist/index.js');\nconsole.log('LavalinkManager:', typeof LavalinkManager);\n```\n\n### Test Bot Not Working?\n\n1. **Lavalink not connected:**\n   - Verify Lavalink is running on configured host/port\n   - Check `application.yml` configuration\n   - Verify password matches\n\n2. **Bot not responding:**\n   - Check bot token is correct\n   - Verify bot has necessary Discord permissions\n   - Check console for errors\n\n3. **No audio playing:**\n   - Verify Lavalink server has Java 17+\n   - Check voice channel permissions\n   - Verify bot can connect to voice\n\n## Success Criteria\n\nYour package is working if:\n- âœ… Builds without errors\n- âœ… All TypeScript types are properly exported\n- âœ… Test bot can connect to Lavalink\n- âœ… Music plays successfully\n- âœ… Queue management works\n- âœ… Filters apply correctly\n- âœ… Events are emitted properly\n- âœ… No memory leaks during extended playback\n\n## Publishing Verification\n\nIf your package is already published to npm:\n\n```bash\n# Test installing from npm\nmkdir test-install\ncd test-install\nnpm init -y\nnpm install aliana-client\nnode -e \"console.log(require('aliana-client'))\"\n```\n\nShould output the exported modules without errors.\n\n## Additional Resources\n\n- [Getting Started Guide](./GETTING_STARTED.md)\n- [API Reference](./API_REFERENCE.md)\n- [Examples](./EXAMPLES.md)\n- [Lavalink Documentation](https://lavalink.dev/)\n\n## Reporting Issues\n\nIf you find issues during testing:\n1. Check if Lavalink v4 is running correctly\n2. Verify your configuration matches the examples\n3. Review console logs for error details\n4. Create an issue with reproduction steps\n\n---\n\nHappy testing! ðŸŽµ\n","size_bytes":5856},"src/utils/MusicCardGenerator.ts":{"content":"import type { Track } from '../structures/Track';\n\nexport interface MusicCardOptions {\n  thumbnailImage?: string;\n  backgroundColor?: string;\n  progress?: number;\n  progressColor?: string;\n  progressBarColor?: string;\n  name?: string;\n  nameColor?: string;\n  author?: string;\n  authorColor?: string;\n  startTime?: string;\n  endTime?: string;\n  timeColor?: string;\n}\n\nexport type MusicCardTheme = 'classic' | 'classicPro' | 'dynamic';\n\nexport class MusicCardGenerator {\n  private static musicardLoaded: boolean = false;\n  private static musicard: any = null;\n\n  private static async loadMusicard(): Promise<void> {\n    if (this.musicardLoaded) {\n      return;\n    }\n\n    try {\n      this.musicard = await import('musicard');\n      this.musicardLoaded = true;\n    } catch (error) {\n      this.musicardLoaded = true;\n      this.musicard = null;\n    }\n  }\n\n  static async generateCard(\n    track: Track,\n    options: MusicCardOptions = {},\n    theme: MusicCardTheme = 'classic'\n  ): Promise<Buffer> {\n    await this.loadMusicard();\n    \n    if (!this.musicard) {\n      throw new Error(\n        'musicard package is not available. Install it with: npm install musicard\\n' +\n        'Note: musiccard is bundled with aliana-client but may not be installed in your environment.'\n      );\n    }\n\n    const defaultOptions: MusicCardOptions = {\n      thumbnailImage: track.info.artworkUrl || track.thumbnail || 'https://via.placeholder.com/300',\n      backgroundColor: '#070707',\n      progress: 0,\n      progressColor: '#FF7A00',\n      progressBarColor: '#5F2D00',\n      name: track.info.title || track.title || 'Unknown Track',\n      nameColor: '#FF7A00',\n      author: track.info.author || track.author || 'Unknown Artist',\n      authorColor: '#696969',\n      startTime: '0:00',\n      endTime: this.formatDuration(track.info.length || track.duration || 0),\n      timeColor: '#FF7A00',\n      ...options,\n    };\n\n    let cardBuffer: Buffer;\n\n    switch (theme) {\n      case 'classicPro':\n        cardBuffer = await this.musicard.ClassicPro(defaultOptions);\n        break;\n      case 'dynamic':\n        cardBuffer = await this.musicard.Dynamic(defaultOptions);\n        break;\n      case 'classic':\n      default:\n        cardBuffer = await this.musicard.Classic(defaultOptions);\n        break;\n    }\n\n    return cardBuffer;\n  }\n\n  static async generateCardWithProgress(\n    track: Track,\n    currentPosition: number,\n    options: MusicCardOptions = {},\n    theme: MusicCardTheme = 'classic'\n  ): Promise<Buffer> {\n    await this.loadMusicard();\n    \n    if (!this.musicard) {\n      throw new Error(\n        'musicard package is not available. Install it with: npm install musicard\\n' +\n        'Note: musiccard is bundled with aliana-client but may not be installed in your environment.'\n      );\n    }\n    \n    const duration = track.info.length || track.duration || 0;\n    const progress = duration > 0 ? Math.min(100, (currentPosition / duration) * 100) : 0;\n\n    return this.generateCard(\n      track,\n      {\n        ...options,\n        progress,\n        startTime: this.formatDuration(currentPosition),\n        endTime: this.formatDuration(duration),\n      },\n      theme\n    );\n  }\n\n  private static formatDuration(ms: number): string {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n\n    if (minutes >= 60) {\n      const hours = Math.floor(minutes / 60);\n      const remainingMinutes = minutes % 60;\n      return `${hours}:${remainingMinutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;\n    }\n\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n  }\n\n  static isAvailable(): boolean {\n    try {\n      require.resolve('musicard');\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n","size_bytes":3832},"docs/styles.css":{"content":"* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\n:root {\n    --primary-color: #5865F2;\n    --secondary-color: #4752C4;\n    --background: #0f0f0f;\n    --surface: #1a1a1a;\n    --surface-light: #242424;\n    --text-primary: #e4e4e7;\n    --text-secondary: #a1a1aa;\n    --border-color: #2f2f2f;\n    --success-color: #22c55e;\n    --warning-color: #f59e0b;\n    --error-color: #ef4444;\n    --code-bg: #1e1e1e;\n    --sidebar-width: 280px;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;\n    background-color: var(--background);\n    color: var(--text-primary);\n    line-height: 1.6;\n    overflow-x: hidden;\n}\n\n.container {\n    display: flex;\n    min-height: 100vh;\n}\n\n.sidebar {\n    width: var(--sidebar-width);\n    background-color: var(--surface);\n    border-right: 1px solid var(--border-color);\n    position: fixed;\n    height: 100vh;\n    overflow-y: auto;\n    z-index: 100;\n    animation: slideInLeft 0.5s ease-out;\n}\n\n@keyframes slideInLeft {\n    from {\n        transform: translateX(-100%);\n        opacity: 0;\n    }\n    to {\n        transform: translateX(0);\n        opacity: 1;\n    }\n}\n\n.sidebar-header {\n    padding: 2rem 1.5rem;\n    border-bottom: 1px solid var(--border-color);\n}\n\n.sidebar-header h1 {\n    font-size: 1.5rem;\n    color: var(--primary-color);\n    margin-bottom: 0.5rem;\n    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    background-clip: text;\n    animation: gradientShift 3s ease infinite;\n}\n\n@keyframes gradientShift {\n    0%, 100% {\n        background-position: 0% 50%;\n    }\n    50% {\n        background-position: 100% 50%;\n    }\n}\n\n.version {\n    color: var(--text-secondary);\n    font-size: 0.875rem;\n}\n\n.search-container {\n    padding: 1rem 1.5rem;\n    border-bottom: 1px solid var(--border-color);\n}\n\n.search-input {\n    width: 100%;\n    padding: 0.75rem 1rem;\n    background-color: var(--surface-light);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    color: var(--text-primary);\n    font-size: 0.875rem;\n    transition: all 0.2s;\n}\n\n.search-input:focus {\n    outline: none;\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 3px rgba(88, 101, 242, 0.1);\n}\n\n.nav-menu {\n    padding: 1rem 0;\n}\n\n.nav-menu ul {\n    list-style: none;\n}\n\n.nav-menu li {\n    margin: 0.25rem 0;\n}\n\n.nav-section {\n    padding: 0.75rem 1.5rem;\n    font-size: 0.75rem;\n    font-weight: 600;\n    text-transform: uppercase;\n    color: var(--text-secondary);\n    letter-spacing: 0.05em;\n    margin-top: 1rem;\n}\n\n.nav-link {\n    display: block;\n    padding: 0.625rem 1.5rem;\n    color: var(--text-secondary);\n    text-decoration: none;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    border-left: 3px solid transparent;\n    position: relative;\n}\n\n.nav-link::before {\n    content: '';\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 3px;\n    height: 0;\n    background: linear-gradient(180deg, var(--primary-color), var(--secondary-color));\n    transition: height 0.3s ease;\n}\n\n.nav-link:hover {\n    color: var(--text-primary);\n    background-color: var(--surface-light);\n    padding-left: 1.75rem;\n}\n\n.nav-link:hover::before {\n    height: 100%;\n}\n\n.nav-link.active {\n    color: var(--primary-color);\n    background-color: rgba(88, 101, 242, 0.1);\n    border-left-color: var(--primary-color);\n    padding-left: 1.75rem;\n}\n\n.nav-link.active::before {\n    height: 100%;\n}\n\n.content {\n    margin-left: var(--sidebar-width);\n    flex: 1;\n    padding: 3rem;\n    max-width: 1200px;\n    animation: fadeIn 0.8s ease-out;\n}\n\n@keyframes fadeIn {\n    from {\n        opacity: 0;\n        transform: translateY(20px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.section {\n    margin-bottom: 4rem;\n    scroll-margin-top: 2rem;\n    animation: fadeInUp 0.6s ease-out;\n    animation-fill-mode: both;\n}\n\n.section:nth-child(1) { animation-delay: 0.1s; }\n.section:nth-child(2) { animation-delay: 0.2s; }\n.section:nth-child(3) { animation-delay: 0.3s; }\n.section:nth-child(4) { animation-delay: 0.4s; }\n\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.section h2 {\n    font-size: 2rem;\n    margin-bottom: 1rem;\n    color: var(--text-primary);\n    border-bottom: 2px solid var(--border-color);\n    padding-bottom: 0.5rem;\n    position: relative;\n    overflow: hidden;\n}\n\n.section h2::after {\n    content: '';\n    position: absolute;\n    bottom: -2px;\n    left: 0;\n    width: 0;\n    height: 2px;\n    background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));\n    transition: width 0.6s ease;\n}\n\n.section:hover h2::after {\n    width: 100%;\n}\n\n.section h3 {\n    font-size: 1.5rem;\n    margin-top: 2rem;\n    margin-bottom: 1rem;\n    color: var(--text-primary);\n}\n\n.section p {\n    margin-bottom: 1rem;\n    color: var(--text-secondary);\n}\n\n.info-box {\n    background-color: rgba(88, 101, 242, 0.1);\n    border-left: 4px solid var(--primary-color);\n    padding: 1.5rem;\n    margin: 1.5rem 0;\n    border-radius: 4px;\n    position: relative;\n    overflow: hidden;\n    transition: all 0.3s ease;\n}\n\n.info-box::before {\n    content: '';\n    position: absolute;\n    top: -50%;\n    right: -50%;\n    width: 200%;\n    height: 200%;\n    background: radial-gradient(circle, rgba(88, 101, 242, 0.1) 0%, transparent 70%);\n    opacity: 0;\n    transition: opacity 0.3s ease;\n}\n\n.info-box:hover::before {\n    opacity: 1;\n}\n\n.info-box:hover {\n    transform: translateX(5px);\n    box-shadow: -4px 0 12px rgba(88, 101, 242, 0.2);\n}\n\n.info-box strong {\n    color: var(--primary-color);\n    display: block;\n    margin-bottom: 0.5rem;\n    font-size: 1.1rem;\n}\n\n.warning-box {\n    background-color: rgba(245, 158, 11, 0.1);\n    border-left: 4px solid var(--warning-color);\n    padding: 1.5rem;\n    margin: 1.5rem 0;\n    border-radius: 4px;\n    position: relative;\n    overflow: hidden;\n    transition: all 0.3s ease;\n}\n\n.warning-box::before {\n    content: '';\n    position: absolute;\n    top: -50%;\n    right: -50%;\n    width: 200%;\n    height: 200%;\n    background: radial-gradient(circle, rgba(245, 158, 11, 0.1) 0%, transparent 70%);\n    opacity: 0;\n    transition: opacity 0.3s ease;\n}\n\n.warning-box:hover::before {\n    opacity: 1;\n}\n\n.warning-box:hover {\n    transform: translateX(5px);\n    box-shadow: -4px 0 12px rgba(245, 158, 11, 0.2);\n}\n\n.warning-box h3 {\n    color: var(--warning-color);\n    margin-top: 0;\n    margin-bottom: 1rem;\n}\n\n.warning-box ul {\n    margin-left: 1.5rem;\n    color: var(--text-secondary);\n}\n\n.warning-box li {\n    margin-bottom: 0.5rem;\n}\n\n.features-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n    gap: 1.5rem;\n    margin-top: 2rem;\n}\n\n.feature-card {\n    background-color: var(--surface);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    padding: 1.5rem;\n    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);\n    position: relative;\n    overflow: hidden;\n}\n\n.feature-card::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -100%;\n    width: 100%;\n    height: 100%;\n    background: linear-gradient(90deg, transparent, rgba(88, 101, 242, 0.1), transparent);\n    transition: left 0.5s ease;\n}\n\n.feature-card:hover::before {\n    left: 100%;\n}\n\n.feature-card:hover {\n    border-color: var(--primary-color);\n    transform: translateY(-8px) scale(1.02);\n    box-shadow: 0 12px 24px rgba(88, 101, 242, 0.3);\n}\n\n.feature-card h3 {\n    font-size: 1.1rem;\n    margin-top: 0;\n    margin-bottom: 0.75rem;\n    color: var(--text-primary);\n}\n\n.feature-card p {\n    margin-bottom: 0;\n    font-size: 0.95rem;\n}\n\n.code-tabs {\n    display: flex;\n    gap: 0.5rem;\n    margin-bottom: -1px;\n}\n\n.tab-button {\n    padding: 0.75rem 1.5rem;\n    background-color: var(--surface-light);\n    border: 1px solid var(--border-color);\n    border-bottom: none;\n    border-radius: 8px 8px 0 0;\n    color: var(--text-secondary);\n    cursor: pointer;\n    font-size: 0.875rem;\n    font-weight: 500;\n    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    position: relative;\n    overflow: hidden;\n}\n\n.tab-button::before {\n    content: '';\n    position: absolute;\n    bottom: 0;\n    left: 50%;\n    width: 0;\n    height: 2px;\n    background: var(--primary-color);\n    transform: translateX(-50%);\n    transition: width 0.3s ease;\n}\n\n.tab-button:hover {\n    background-color: var(--surface);\n    color: var(--text-primary);\n    transform: translateY(-2px);\n}\n\n.tab-button:hover::before {\n    width: 80%;\n}\n\n.tab-button.active {\n    background-color: var(--code-bg);\n    color: var(--primary-color);\n    border-color: var(--border-color);\n    transform: translateY(-2px);\n}\n\n.tab-button.active::before {\n    width: 100%;\n}\n\n.tab-content {\n    display: none;\n}\n\n.tab-content.active {\n    display: block;\n}\n\npre {\n    background-color: var(--code-bg);\n    border: 1px solid var(--border-color);\n    border-radius: 8px;\n    padding: 1.5rem;\n    overflow-x: auto;\n    margin: 1rem 0;\n    position: relative;\n    transition: all 0.3s ease;\n}\n\npre:hover {\n    border-color: var(--primary-color);\n    box-shadow: 0 4px 12px rgba(88, 101, 242, 0.15);\n    transform: translateY(-2px);\n}\n\ncode {\n    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;\n    font-size: 0.875rem;\n    line-height: 1.6;\n}\n\np code, li code, td code {\n    background-color: var(--surface-light);\n    padding: 0.2rem 0.4rem;\n    border-radius: 4px;\n    font-size: 0.85rem;\n    color: var(--primary-color);\n}\n\n.methods-table {\n    width: 100%;\n    border-collapse: collapse;\n    margin: 1.5rem 0;\n    background-color: var(--surface);\n    border-radius: 8px;\n    overflow: hidden;\n}\n\n.methods-table thead {\n    background-color: var(--surface-light);\n}\n\n.methods-table th {\n    padding: 1rem;\n    text-align: left;\n    font-weight: 600;\n    color: var(--text-primary);\n    border-bottom: 2px solid var(--border-color);\n}\n\n.methods-table td {\n    padding: 1rem;\n    border-bottom: 1px solid var(--border-color);\n    color: var(--text-secondary);\n}\n\n.methods-table tbody tr:last-child td {\n    border-bottom: none;\n}\n\n.methods-table tbody tr {\n    transition: all 0.2s ease;\n}\n\n.methods-table tbody tr:hover {\n    background-color: var(--surface-light);\n    transform: scale(1.01);\n    box-shadow: 0 2px 8px rgba(88, 101, 242, 0.1);\n}\n\n.footer {\n    margin-top: 4rem;\n    padding-top: 2rem;\n    border-top: 1px solid var(--border-color);\n    text-align: center;\n    color: var(--text-secondary);\n}\n\n.footer p {\n    margin-bottom: 0.5rem;\n}\n\n.footer a {\n    color: var(--primary-color);\n    text-decoration: none;\n    transition: color 0.2s;\n}\n\n.footer a:hover {\n    color: var(--secondary-color);\n}\n\n.back-to-top {\n    position: fixed;\n    bottom: 2rem;\n    right: 2rem;\n    width: 3rem;\n    height: 3rem;\n    background-color: var(--primary-color);\n    color: white;\n    border: none;\n    border-radius: 50%;\n    font-size: 1.5rem;\n    cursor: pointer;\n    opacity: 0;\n    visibility: hidden;\n    transition: all 0.3s;\n    z-index: 1000;\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n}\n\n.back-to-top.visible {\n    opacity: 1;\n    visibility: visible;\n}\n\n.back-to-top:hover {\n    background-color: var(--secondary-color);\n    transform: translateY(-2px);\n    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);\n}\n\n::-webkit-scrollbar {\n    width: 12px;\n}\n\n::-webkit-scrollbar-track {\n    background: var(--background);\n}\n\n::-webkit-scrollbar-thumb {\n    background: var(--surface-light);\n    border-radius: 6px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: var(--border-color);\n}\n\n.particles {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n    z-index: 1;\n    overflow: hidden;\n}\n\n.particle {\n    position: absolute;\n    width: 2px;\n    height: 2px;\n    background: var(--primary-color);\n    border-radius: 50%;\n    opacity: 0.3;\n    animation: float linear infinite;\n}\n\n@keyframes float {\n    0% {\n        transform: translateY(100vh) scale(0);\n        opacity: 0;\n    }\n    10% {\n        opacity: 0.3;\n    }\n    90% {\n        opacity: 0.3;\n    }\n    100% {\n        transform: translateY(-10vh) scale(1);\n        opacity: 0;\n    }\n}\n\n@media (max-width: 768px) {\n    .sidebar {\n        transform: translateX(-100%);\n        transition: transform 0.3s;\n    }\n\n    .sidebar.open {\n        transform: translateX(0);\n    }\n\n    .content {\n        margin-left: 0;\n        padding: 1.5rem;\n    }\n\n    .features-grid {\n        grid-template-columns: 1fr;\n    }\n\n    .back-to-top {\n        bottom: 1rem;\n        right: 1rem;\n    }\n}","size_bytes":12748},"docs/script.js":{"content":"document.addEventListener('DOMContentLoaded', () => {\n    if (typeof hljs !== 'undefined') {\n        hljs.highlightAll();\n    }\n    \n    initNavigation();\n    initTabs();\n    initSearch();\n    initBackToTop();\n    initParticles();\n});\n\nfunction initNavigation() {\n    const navLinks = document.querySelectorAll('.nav-link');\n    const sections = document.querySelectorAll('.section');\n    \n    const observerOptions = {\n        root: null,\n        rootMargin: '-20% 0px -75% 0px',\n        threshold: 0\n    };\n    \n    const observer = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                const id = entry.target.getAttribute('id');\n                navLinks.forEach(link => {\n                    link.classList.remove('active');\n                    if (link.getAttribute('href') === `#${id}`) {\n                        link.classList.add('active');\n                    }\n                });\n            }\n        });\n    }, observerOptions);\n    \n    sections.forEach(section => {\n        observer.observe(section);\n    });\n    \n    navLinks.forEach(link => {\n        link.addEventListener('click', (e) => {\n            e.preventDefault();\n            const targetId = link.getAttribute('href').substring(1);\n            const targetSection = document.getElementById(targetId);\n            \n            if (targetSection) {\n                const offsetTop = targetSection.offsetTop - 20;\n                window.scrollTo({\n                    top: offsetTop,\n                    behavior: 'smooth'\n                });\n            }\n        });\n    });\n}\n\nfunction initTabs() {\n    const tabButtons = document.querySelectorAll('.tab-button');\n    \n    tabButtons.forEach(button => {\n        button.addEventListener('click', () => {\n            const tabName = button.getAttribute('data-tab');\n            const tabContainer = button.closest('.section');\n            \n            tabContainer.querySelectorAll('.tab-button').forEach(btn => {\n                btn.classList.remove('active');\n            });\n            \n            tabContainer.querySelectorAll('.tab-content').forEach(content => {\n                content.classList.remove('active');\n            });\n            \n            button.classList.add('active');\n            const activeContent = tabContainer.querySelector(`#${tabName}`);\n            if (activeContent) {\n                activeContent.classList.add('active');\n            }\n        });\n    });\n}\n\nfunction initSearch() {\n    const searchInput = document.getElementById('searchInput');\n    const sections = document.querySelectorAll('.section');\n    let searchTimeout;\n    \n    searchInput.addEventListener('input', (e) => {\n        clearTimeout(searchTimeout);\n        \n        searchTimeout = setTimeout(() => {\n            const searchTerm = e.target.value.toLowerCase().trim();\n            \n            if (searchTerm === '') {\n                sections.forEach(section => {\n                    section.style.display = 'block';\n                });\n                return;\n            }\n            \n            sections.forEach(section => {\n                const text = section.textContent.toLowerCase();\n                const id = section.getAttribute('id');\n                const heading = section.querySelector('h2')?.textContent.toLowerCase() || '';\n                \n                if (text.includes(searchTerm) || heading.includes(searchTerm) || id?.includes(searchTerm)) {\n                    section.style.display = 'block';\n                    highlightSearchTerms(section, searchTerm);\n                } else {\n                    section.style.display = 'none';\n                }\n            });\n        }, 300);\n    });\n}\n\nfunction highlightSearchTerms(section, term) {\n    const walker = document.createTreeWalker(\n        section,\n        NodeFilter.SHOW_TEXT,\n        null,\n        false\n    );\n    \n    const textNodes = [];\n    let node;\n    \n    while (node = walker.nextNode()) {\n        if (node.parentElement.tagName !== 'CODE' && \n            node.parentElement.tagName !== 'PRE' &&\n            node.nodeValue.trim() !== '') {\n            textNodes.push(node);\n        }\n    }\n    \n    textNodes.forEach(textNode => {\n        const text = textNode.nodeValue;\n        const lowerText = text.toLowerCase();\n        \n        if (lowerText.includes(term)) {\n            const regex = new RegExp(`(${term})`, 'gi');\n            const span = document.createElement('span');\n            span.innerHTML = text.replace(regex, '<mark style=\"background-color: rgba(88, 101, 242, 0.3); padding: 2px 4px; border-radius: 3px;\">$1</mark>');\n            textNode.parentNode.replaceChild(span, textNode);\n        }\n    });\n}\n\nfunction initBackToTop() {\n    const backToTopButton = document.getElementById('backToTop');\n    \n    window.addEventListener('scroll', () => {\n        if (window.pageYOffset > 300) {\n            backToTopButton.classList.add('visible');\n        } else {\n            backToTopButton.classList.remove('visible');\n        }\n    });\n    \n    backToTopButton.addEventListener('click', () => {\n        window.scrollTo({\n            top: 0,\n            behavior: 'smooth'\n        });\n    });\n}\n\nwindow.addEventListener('scroll', () => {\n    const scrolled = window.pageYOffset;\n    const navbar = document.querySelector('.sidebar-header');\n    \n    if (scrolled > 50 && navbar) {\n        navbar.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';\n    } else if (navbar) {\n        navbar.style.boxShadow = 'none';\n    }\n});\n\nfunction initParticles() {\n    const particlesContainer = document.getElementById('particles');\n    const particleCount = 30;\n    \n    for (let i = 0; i < particleCount; i++) {\n        createParticle(particlesContainer);\n    }\n    \n    setInterval(() => {\n        if (particlesContainer.children.length < particleCount) {\n            createParticle(particlesContainer);\n        }\n    }, 3000);\n}\n\nfunction createParticle(container) {\n    const particle = document.createElement('div');\n    particle.className = 'particle';\n    \n    const startX = Math.random() * window.innerWidth;\n    const duration = 15 + Math.random() * 10;\n    const delay = Math.random() * 5;\n    const size = 1 + Math.random() * 2;\n    \n    particle.style.left = startX + 'px';\n    particle.style.width = size + 'px';\n    particle.style.height = size + 'px';\n    particle.style.animationDuration = duration + 's';\n    particle.style.animationDelay = delay + 's';\n    \n    container.appendChild(particle);\n    \n    setTimeout(() => {\n        particle.remove();\n    }, (duration + delay) * 1000);\n}","size_bytes":6620}},"version":2}